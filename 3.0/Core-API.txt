


Network Working Group
Internet-Draft                                                April 2012
Expires: October 01, 2012

                 OpenSocial Core API Specification 3.0

Abstract

   TBD

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on October 01, 2012.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (http://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2
     1.1.  Notation and Conventions . . . . . . . . . . . . . . . . .  2
   2.  REST Services  . . . . . . . . . . . . . . . . . . . . . . . .  3
     2.1.  Common URI Structure . . . . . . . . . . . . . . . . . . .  4
     2.2.  Service Identifiers  . . . . . . . . . . . . . . . . . . .  6
     2.3.  Local Identifiers  . . . . . . . . . . . . . . . . . . . .  7
       2.3.1.  The "@me" Alias  . . . . . . . . . . . . . . . . . . .  7
       2.3.2.  The "@anonymous" Alias . . . . . . . . . . . . . . . .  7
       2.3.3.  The "@public" Alias  . . . . . . . . . . . . . . . . .  7

(surname)               Expires October 01, 2012                [Page 1]

Internet-Draft                  Core-API                      April 2012

       2.3.4.  Legacy Global Identifiers  . . . . . . . . . . . . . .  7
     2.4.  Aspect Identifiers . . . . . . . . . . . . . . . . . . . .  8
     2.5.  Filters  . . . . . . . . . . . . . . . . . . . . . . . . .  9
     2.6.  Standard Query Parameters  . . . . . . . . . . . . . . . . 10
       2.6.1.  The "filterOp" Parameter . . . . . . . . . . . . . . . 12
       2.6.2.  The "sort" Parameter . . . . . . . . . . . . . . . . . 13
     2.7.  Conditional Requests . . . . . . . . . . . . . . . . . . . 13
     2.8.  Full vs. Partial Modification  . . . . . . . . . . . . . . 15
       2.8.1.  PATCH Document Formats . . . . . . . . . . . . . . . . 16
     2.9.  Error Handling . . . . . . . . . . . . . . . . . . . . . . 18
       2.9.1.  The Error Object . . . . . . . . . . . . . . . . . . . 20
     2.10. Multiple resource and aspect operations  . . . . . . . . . 20
     2.11. Operation Identifiers  . . . . . . . . . . . . . . . . . . 26
   3.  Dates, Times and Timezone Offsets  . . . . . . . . . . . . . . 26
   4.  Data Objects . . . . . . . . . . . . . . . . . . . . . . . . . 27
     4.1.  Collection Objects . . . . . . . . . . . . . . . . . . . . 28
       4.1.1.  Multi-page Collections . . . . . . . . . . . . . . . . 30
     4.2.  Plural Objects . . . . . . . . . . . . . . . . . . . . . . 32
     4.3.  Data Object Extensions . . . . . . . . . . . . . . . . . . 34
       4.3.1.  Avoiding Naming Conflicts  . . . . . . . . . . . . . . 35
     4.4.  Data Object Type Identifiers . . . . . . . . . . . . . . . 35
       4.4.1.  Legacy Data Type Identifiers . . . . . . . . . . . . . 36
   5.  Security . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
     5.1.  OAuth 1.0a and 2.0 Support . . . . . . . . . . . . . . . . 37
     5.2.  Signed Fetch . . . . . . . . . . . . . . . . . . . . . . . 38
   6.  Versioning . . . . . . . . . . . . . . . . . . . . . . . . . . 38
     6.1.  Upgrade Indication and Transition  . . . . . . . . . . . . 39
   7.  Registry of Service Identifiers  . . . . . . . . . . . . . . . 40
   8.  Registry of Aspect Identifiers . . . . . . . . . . . . . . . . 41
   9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 42
     9.1.  Normative References . . . . . . . . . . . . . . . . . . . 42
     9.2.  Informative References . . . . . . . . . . . . . . . . . . 44
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 44

1.  Introduction

   TBD

1.1.  Notation and Conventions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC2119 [RFC2119].

   Some sections of this specification are illustrated with fragments of
   a Augmented Backus-Naur Form [RFC5234] (ABNF) grammar.  The rules
   specified are normative.

   This specification allows the use of IRIs [RFC3987].  Every URI
   [RFC3986] is also an IRI, so a URI may be used wherever an IRI is
   named.  There are two special considerations: (1) when an IRI that is
   not also a URI is given for dereferencing, it MUST be mapped to a URI
   using the steps in Section 3.1 of RFC 3987.  and (2) when an IRI is




(surname)               Expires October 01, 2012                [Page 2]

Internet-Draft                  Core-API                      April 2012

   serving as an identifier, it MUST NOT be so mapped.

2.  REST Services

   OpenSocial REST Services consist of collections of Web-accessible
   resources that can be accessed and modified using the basic set of
   HTTP request methods as defined by [I-D.ietf-httpbis-p2-semantics].
   Such services are intended to be used either by OpenSocial
   Applications as defined by [core-gadget] or other third parties to
   access social data hosted and managed by an OpenSocial-enabled
   server.

   In general, for all REST Services:

      the HTTP GET method is used to retrieve representations of the
      current state of a any given resource,

      PUT and PATCH are used to modify the current state,

      DELETE is used to delete the resource,

      and POST is used to either create new resources or to perform
      other types of operations that do not fit within the scope of the
      other core HTTP methods.

   Implementations are free to support additional HTTP methods but their
   use is considered to be outside the scope of this specification.

   Resources made available via a REST Service can represent individual
   objects (e.g.  a person, a document, an activity) or collections of
   objects (e.g.  a friends list, a folder containing multiple files, a
   listing of events). Every resource is identified by a distinct URI to
   which the various HTTP methods are to be sent.

   For example, to retrieve a user's current profile using the
   OpenSocial Person Service, a client application would issue a GET
   request:

   GET /api/people/@me/@self HTTP/1.1
   Host: api.example.org

   When a client application is required to communicate with an
   OpenSocial server via an intermediary that restricts the use of
   certain standard and extension HTTP Methods (e.g.  PUT, DELETE,
   PATCH), the client SHOULD utilize the "X-HTTP-Method-Override" HTTP
   Request Header mechanism in a POST request.

   For example, the HTTP PATCH request method is still relatively new
   and is not yet fully supported by deployed HTTP infrastructure.  It
   is therefore possible that PATCH requests might be blocked by certain
   intermediaries.  To address such cases, the PATCH request may be
   modified by sending a POST request that includes the "X-HTTP-Method-



(surname)               Expires October 01, 2012                [Page 3]

Internet-Draft                  Core-API                      April 2012

   Override" HTTP header:

     POST /api/people/@me/@self HTTP/1.1
     Host: api.example.org
     Content-Type: application/json
     X-HTTP-Method-Override: PATCH
   
     {...}

   OpenSocial Servers MUST respond to such requests as if the method
   specified by the "X-HTTP-Method-Override" was the actual operation
   used by the request, as opposed to POST.

   The "X-HTTP-Method-Override" header MUST NOT be used to send HTTP GET
   requests.

   Responses to all requests will specify an appropriate HTTP Status
   Code indicating the status of the response.

2.1.  Common URI Structure

   All REST Services share a common, basic URI Structure that MAY be
   extended on a case-by-case basis.  This common structure helps to
   ensure that all interactions remain as consistent as possible across
   multiple REST Services while allowing individual service-specific and
   implementation specific behaviors to be supported.

   By convention, the Common URI Structure is described using a URL
   Template [RFC6570]:

   {protocol}://{+host}{/rootpath*,service-identifier,local-identifier,aspect-identifier,filters*}{?parameters*}
























(surname)               Expires October 01, 2012                [Page 4]

Internet-Draft                  Core-API                      April 2012


   +---------------------+---------------------------------------------+
   | Expression          | Description                                 |
   +---------------------+---------------------------------------------+
   | protocol            | Indicates either "http" or "https"          |
   |                     | depending on whether or not SSL or TLS is   |
   |                     | to be used with the request.                |
   | host                | Specifies the DNS Host Name and, if         |
   |                     | necessary, the TCP/IP port at which the     |
   |                     | REST service is available. For instance,    |
   |                     | "api.example.org" or                        |
   |                     | "api.example.org:8080".                     |
   | rootpath            | Specifies the root path of the REST         |
   |                     | Service. The value is specified as an Array |
   |                     | of isegment-nz path segments as defined by  |
   |                     | [RFC3987]. For example, ["services","api"], |
   |                     | which when expanded by the URL Template     |
   |                     | produces "/services/api".                   |
   | service-identifier  | The service identifier as defined by        |
   |                     | Section 2.2.                                |
   | local-identifier    | The local-identifier of a data object, as   |
   |                     | defined by Section 2.3 that is the target   |
   |                     | of an HTTP request.                         |
   | aspect-identifier   | An aspect-identifier, as defined by Section |
   |                     | 2.4, that identifies the specific aspect of |
   |                     | the identified Data Object to which the     |
   |                     | HTTP request is being directed. For         |
   |                     | instance, if the intent of the request is   |
   |                     | to retrieve the list of other people        |
   |                     | connected to a particular user's profile,   |
   |                     | the local-identifier specifies the target   |
   |                     | user's local-identifier and the aspect-     |
   |                     | identifier would specify "@friends".        |
   | filters             | A set of zero or more service, resource and |
   |                     | aspect specific path segments that specify  |
   |                     | additional filters for the request (see     |
   |                     | Section 2.5). The value is specified as an  |
   |                     | Array, each member of which can either be   |
   |                     | an isegment-nz path segment or an Array of  |
   |                     | isegment-nz path segments. For instance,    |
   |                     | the value ["a","b","c"] would expand within |
   |                     | the URL Template to "/a/b/c"; whereas the   |
   |                     | value ["a",["b","c"]] would expand to       |
   |                     | "/a/b,c".                                   |
   | parameters          | Specifies a collection of query parameters  |
   |                     | associated with the request, specified as a |
   |                     | collection of name and value pairs. All     |
   |                     | REST Services are required to support a     |
   |                     | common core collection of query parameters  |
   |                     | as defined in Section 2.6 and MAY introduce |
   |                     | additional service, resource and aspect     |
   |                     | specific parameters.                        |
   +---------------------+---------------------------------------------+


(surname)               Expires October 01, 2012                [Page 5]

Internet-Draft                  Core-API                      April 2012


   To illustrate how the common URI structure operates, consider the
   following example.  For each of the URI Template variables, assume
   the following values:

   +----------------------+--------------------------------------------+
   | Variable             | Value                                      |
   +----------------------+--------------------------------------------+
   | protocol             | https                                      |
   | host                 | api.example.org                            |
   | rootpath             | ["service","api"]                          |
   | service-identifier   | people                                     |
   | local-identifier     | @me                                        |
   | aspect-identifier    | @friends                                   |
   | filters              | ["@recent"]                                |
   | parameters           | {"count":"10",                             |
   |                      | "updatedAfter":"2012-04-16T00:00:00Z"}     |
   +----------------------+--------------------------------------------+

   When applied to the common URI Template, the Request URI Generated
   becomes: "https://api.example.org/service/api/people/@me/@friends/
   @recent?count=10&updatedAfter=2012-04-16T00:00:00Z".

2.2.  Service Identifiers

   Service Identifiers are simple text labels, conforming to the
   isegment-nz construction defined in [RFC3987], used to identify an
   individual OpenSocial REST service.

   service-identifier = isegment-nz

   For instance, the OpenSocial Person Service is identified using the
   label "people" while the Activity Stream Service is identified using
   the label "activity".

   An example request to retrieve a person's profile using the Person
   Service:

   GET /service/api/people/@me/@self HTTP/1.1
   Host: example.org

   An example request to retrieve an Activity Stream associated with a
   person using the Activity Stream Service:

   GET /service/api/activity/@me/@all HTTP/1.1
   Host: example.org

   Please refer to the [social-app] specification for complete details
   on the core set of social data services defined by this version of
   the OpenSocial specification.  Implementations are free to implement
   additional services.

   If a particular implementation does not support a given specified
   service, it SHOULD simply return a 404 Not Found response.

(surname)               Expires October 01, 2012                [Page 6]

Internet-Draft                  Core-API                      April 2012


2.3.  Local Identifiers

   Every individual data object managed and made available via a REST
   service is uniquely identified within that service's context by a
   local-identifier.

   The local identifier is an opaque String conforming to the isegment-
   nz construction of [RFC3987].  This string unique identifies the
   object within the context of the service with which the object is
   associated.

   local-identifier = isegment-nz

2.3.1.  The "@me" Alias

   The literal string value "@me" MAY be used as an alias for the local-
   identifier of the currently authenticated entity.

   For instance, if a person uses the OpenSocial Person Service to
   request information about their own social data profile, the request
   URI can specify the "@me" alias as opposed to the requester's local-
   identifier.  The server fullfilling the request would use the
   requests authentication context to determine the appropriate local-
   identifier.

2.3.2.  The "@anonymous" Alias

   The literal string value "@anonymous" MAY be used as an alias for the
   local-identifier of any anonymous, non-authenticated entity.

   Previous versions of this specification used the numeric integer
   value -1 (negative one) to identify anonymous, non-authenticated
   users.  The use of the numeric integer is considered to be deprecated
   and SHOULD NOT be used; however implementations MAY continue to
   support the use of -1 in order to maintain backwards compatibility
   with older applications.

2.3.3.  The "@public" Alias

   The literal string value "@public" is provided as a local-identifier
   identifying the total collection of "public" resources provided by a
   REST service.  For instance, if a requesting application wishes to
   use the OpenSocial Activity Service to retrieve a listing of all
   recent public Activities that have occurred independent of the
   specific person or resource with which those activities are
   associated, the request URI can specify "@public" as the local-
   identifier.

   The "@public" alias might not be supported by all REST services or
   implementations.

2.3.4.  Legacy Global Identifiers


(surname)               Expires October 01, 2012                [Page 7]

Internet-Draft                  Core-API                      April 2012


   Previous versions of this specification utilized an older form of
   "global identifier" that has since been deprecated.  Server
   implementations MAY continue to support the older format for
   backwards-compatibility purposes with existing applications but new
   applications SHOULD NOT make use of the deprecated syntax.

   The legacy syntax consisted of a combination of a DNS domain name and
   an object's local identifier separated by a colon (":") character.

   domain-name = *( ALPHA / DIGIT / "_" / "." / "-" )
   legacy-global-identifier   = domain-name ":" local-identifier

2.4.  Aspect Identifiers

   Every type of Data Object provided by a REST service can have zero or
   more distinct aspects to which requests can be directed.  These
   aspects are always specific to the individual type of resource and
   service.  Aspects are identified within the URL structure using an
   aspect-identifier.

   aspect-identifier = "@" isegment-nz

   For example, Person Data Objects as defined by the [social-app]
   expose a number of Aspects that are specific to the social data that
   makes up a person's profile data.  For instance:

   o  There is the "@self" Aspect that references the person's own
      profile detail (i.e.  their name, contact information, interests,
      etc);

   o  The "@friends" Aspect that references the person's network of
      directly connected friends and associates;

   o  The "@network" Aspect that references the person's extended
      network (i.e.  friends-of-friends, etc).

   To retrieve information about specific aspects, the appropriate
   aspect-identifier would be included in the request URI.

     GET /service/api/people/@me/@self HTTP/1.1
     Host: example.org
   
     GET /service/api/people/@me/@friends HTTP/1.1
     Host: example.org
   
     GET /service/api/people/@me/@network HTTP/1.1
     Host: example.org

   Please refer to [social-app] for complete details on the specific
   aspects associated with each of the core OpenSocial Social Data
   Objects and services.  Implementations are free to define additional
   aspects for any of the core Social Data Objects and Services.


(surname)               Expires October 01, 2012                [Page 8]

Internet-Draft                  Core-API                      April 2012


   To prevent against the likelihood of compatibility issues arising
   through the use and extension of aspects by implementations as well
   to promote the reuse and socialization of new aspect-identifiers,
   this document establishes a registry of common aspect identifiers.
   (Section 8) It is RECOMMENDED that all aspect-identifiers used within
   OpenSocial implementations be added to the registry per the
   requirements detailed in Section 8.

   If a particular implementation does not support a given specified
   aspect, it SHOULD simply return a 404 Not Found response.

2.5.  Filters

   The Common URI Structure also supports the use of service, data
   object and aspect specific filters that can be used to further define
   the scope of a particular REST request.  When expressed within the
   request URI, such filters take the form of an arbitrary set of
   additional isegment-nz path segments.

   Implementations MAY choose to allow multiple filter identifiers
   separated by a comma (,) character within a single path segment.
   When multiple, comma-separated filter identifiers are specified, they
   are to be interpreted as distinct alternatives (e.g.  the filter
   segment "a,b" is to be interpreted as "a or b" as opposed to "a and
   b").

   filter = isegment-nz

   For example, an application that is requesting a listing of Activity
   Objects provided by the OpenSocial Activity Stream service may wish
   to limited the returned set of activities to only those generated by
   particular applications.  To do so, the application would identify
   the applications using filter segments:

   GET /service/api/activity/@me/@all/app-1,app-2
   Host: example.org

   Alternatively, an implementation can choose to allow applications to
   limit the results returned by the request to only those that have
   been "tagged" with a particular label.  This is strictly an non-
   normative example illustrating the basic function of filters as
   "tagging" of Data Objects is not defined by this specification:

   GET /service/api/activity/@me/@all/@tags/foo,bar

   When an implementation supports and applies filters, they MUST be
   interpreted as a hierarchy, with each subsequent path segment being
   interpreted relative to the previous segment.  The exact application
   of the filters is left to the implementation, however.

   For example, given the hypothetical request:

   GET /service/api/activity/@me/@all/app-1,app-2/@tags/foo,bar

(surname)               Expires October 01, 2012                [Page 9]

Internet-Draft                  Core-API                      April 2012


   The appropriate way to interpret this request is: Return the list of
   all activities for the authenticated user generated by either app-1
   or app-2 that have been tagged with either "foo" or "bar".

   Please refer to [social-app] for complete detail on specific filters
   associated with each of the core OpenSocial Social Data Objects and
   services.  Implementations are free to define additional filters for
   any of the core Social Data Objects and Services.

   If a particular implementation does not support a given specified
   filter, it SHOULD simply return a 404 Not Found response.

2.6.  Standard Query Parameters

   All REST services MUST support a common set of URI Query String
   parameters that can be used to modify the processing of the request
   and the information returned to the client.





































(surname)               Expires October 01, 2012               [Page 10]

Internet-Draft                  Core-API                      April 2012


   +----------------+--------------------------------------------------+
   | Name           | Description                                      |
   +----------------+--------------------------------------------------+
   | count          | When the resource to which a request is directed |
   |                | represents a collection of items and the         |
   |                | intention of the request is to retrieve a        |
   |                | listing of a subset of those items, the count    |
   |                | value specifies the maximum number of items to   |
   |                | return. The value is specified as a non-negative |
   |                | integer. If unspecified, the server is free to   |
   |                | determine a reasonable default value. No default |
   |                | value is assumed. If a value of zero (0) is      |
   |                | specified then it is to be interpreted as a      |
   |                | request for an empty collection. If any value    |
   |                | other than a non-negative integer value is       |
   |                | specified, the parameter SHOULD be ignored as if |
   |                | the parameter were not present at all.           |
   | fields         | The fields parameter allows a client application |
   |                | retrieving information about a resource to       |
   |                | specify individual pieces of information it is   |
   |                | interested in receiving as a simple, comma       |
   |                | separated list. For instance,                    |
   |                | "fields=name,email". The server MAY choose to    |
   |                | return a representation of the requested         |
   |                | information containing only the requested fields |
   |                | along with any additional information the server |
   |                | determines is required. If the resource          |
   |                | identified by the URI represents a collection of |
   |                | individual objects, the fields parameter         |
   |                | identifies the requested properties of those     |
   |                | individual objects, rather than the properties   |
   |                | of the collection.                               |
   | filterBy       | When the resource to which a request is directed |
   |                | represents a collection of items and the         |
   |                | intention of the request is to retrieve a subset |
   |                | of those items, the filterBy parameter specifies |
   |                | the name of a field to be used as a selection    |
   |                | filter to determine the subset of items to       |
   |                | return. The value of the parameter is the name   |
   |                | of a field contained by each of the objects in   |
   |                | the collection. This property is intended to be  |
   |                | used in conjunction with the filterOp and        |
   |                | filterValue parameters.                          |
   | filterOp       | When the filterBy parameter is used to specify   |
   |                | the name of a field to use as a selection        |
   |                | filter, the filterOp parameter is used to        |
   |                | specify the specific type of selection filter    |
   |                | operation to apply. See Section 2.6.1 for        |
   |                | details on the possible values for the           |
   |                | "filterOp" parameter.                            |
   | filterValue    | When using the filterBy and filterOp parameters, |
   |                | and filterOp equals "contains", "equals" or      |


(surname)               Expires October 01, 2012               [Page 11]

Internet-Draft                  Core-API                      April 2012

   |                | "startsWith", the filterValue parameter          |
   |                | specifies the value against which the value of   |
   |                | the filterBy field is tested.                    |
   | sort           | When the resource to which a request is directed |
   |                | represents a collection of items and the         |
   |                | intention of the request is to retrieve a        |
   |                | listing of those items, the sort parameter       |
   |                | specifies one or more fields to be used as a     |
   |                | sorting index and the order in which items       |
   |                | SHOULD be returned. The value is a comma         |
   |                | separated list of sort-key definitions as        |
   |                | specified in Section 2.6.2.                      |
   | startIndex     | When the resource to which a request is directed |
   |                | represents a collection of items and the         |
   |                | intention of the request is to retrieve a subset |
   |                | of those items, the startIndex parameter         |
   |                | specifies the relative position of the first     |
   |                | item to return out of the total set of items     |
   |                | that can be returned as determined by the server |
   |                | after any requested filtering and sorting of the |
   |                | set as been applied. The index is 0-based such   |
   |                | that to return the first item of the set, the    |
   |                | startIndex parameter value would be 0.           |
   | updatedSince   | When the resource to which a request is directed |
   |                | represents a collection of items and the         |
   |                | intention of the request is to retrieve a subset |
   |                | of those items, the updatedSince parameter       |
   |                | specifies that the server SHOULD only return     |
   |                | items that have been updated after a given date  |
   |                | and time. The value is expressed as an RFC 3339  |
   |                | date-time as described in Section 3.             |
   | updatedBefore  | When the resource to which a request is directed |
   |                | represents a collection of items and the         |
   |                | intention of the request is to retrieve a subset |
   |                | of those items, the updatedBefore parameter      |
   |                | specifies that the server SHOULD only return     |
   |                | items updated before the given date and time.    |
   |                | The value is expressed as an RFC 3339 date-time  |
   |                | as described in Section 3.                       |
   +----------------+--------------------------------------------------+

2.6.1.  The "filterOp" Parameter

   The value of the "filterOp" parameter is one of:

   contains Indicates that the value of the field identified by the
      filterBy parameter MUST contain the exact value specified by the
      filterValue parameter.

   equals Indicates that the value of the field identified by the
      filterBy parameter MUST equal the exact value specified by the
      filterValue parameter.



(surname)               Expires October 01, 2012               [Page 12]

Internet-Draft                  Core-API                      April 2012


   startsWith Indicates that the value of the field identified by the
      filterBy parameter MUST begin with the exact characters specified
      by the filterValue parameter.

   present Indicates that items are only considered to match the
      selection filter if the field identified by the filterBy parameter
      is present within the item and specifies a non-null value.  When
      filterOp equals "present", the filterValue parameter is ignored.

2.6.2.  The "sort" Parameter

   The value of the "sort" parameter is a comma-separated list of sort-
   keys as defined below.

   sort-default-order = field
   sort-default-field = "+" / "-"
   sort-order-field = ("+" / "-") field
   sort-key = sort-default-order / sort-default-field / sort-order-field

   Each sort-key consists of an optional ASCII plus (+) or minus (-)
   character that indicates the requested sorting order -- where plus
   indicates ascending and minus indicates descending -- and the name of
   a field to sort by.

   For instance, to request that the items of the collection be returned
   in reverse chronological order by the date and time they were last
   updated, assuming each item in the collection has an "updated" field,
   the value of the sort parameter would be: "sort=-updated".

   Multiple sort-keys MAY be specified.  For instance, to request that
   the items of the collection be returned in reverse chronological
   order by the date and time they were last updated, but in
   alphabetical order by the title field, the value of the sort
   parameter would be: "sort=-updated,+title".

   If the optional plus or minus indicator is omitted, the server shall
   determine an appropriate default sorting order.

   If the sort parameter specifies a field that is unsupported for the
   type of objects within the collection, the unsupported field MUST be
   ignored.

2.7.  Conditional Requests

   All REST services MUST support the use of Conditional Request









(surname)               Expires October 01, 2012               [Page 13]

Internet-Draft                  Core-API                      April 2012

   mechanisms as defined in [I-D.ietf-httpbis-p4-conditional].

   When returning the current representation of any resource, whether
   that representation is for a single object or a collection of
   objects, the HTTP Response MUST include either a strong Entity Tag as
   defined in Section 2.3 of [I-D.ietf-httpbis-p4-conditional], a Last-
   Modified Timestamp as specified in Section 2.2, or both.

   For example, the response to a request retrieving the current
   representation of a person's profile might include both an Entity Tag
   and a Last-Modified timestamp:

   HTTP/1.1 200 OK
   Content-Type: application/json
   ETag: "ab12cd34ef56"
   Last-Modified: Tue, 15 Nov 2012 12:45:26 GMT

   Once a client has the Entity Tag or Last-Modified timestamp for a
   given resource representation, subsequent requests SHOULD utilize one
   or the other within a conditional request to optimize communication
   and to ensure that multiple clients do not inadvertently overwrite
   each other's data.

   For instance, given the Last-Modified Timestamp included in a
   response to a request to receive a user's profile, a client can
   request that the server return an updated view of the profile if, and
   only if the state of the profile has changed since the specified
   time:

   GET /api/people/@me/@self HTTP/1.1
   If-Modified-Since: Tue, 15 Nov 1994 12:45:26 GMT

   If the profile has not been modified since the date specified, the
   server would respond with a "304 Not Modified" status.

   Given the Entity Tag of a resource representation, a client wishing
   to modify the resource can request that changes only be applied if
   the resource has not been subsequently modified since the original
   representation and Entity Tag were created:

     PUT /api/people/@me/@self HTTP/1.1
     If-Match: "ab12cd34ef56"
     Content-Type: application/json
   
     {...}

   If the server is unable to determine that the specified Entity Tag
   applies to the current state of the resource, it will abort the
   change request and respond to the request using a "412 Precondition
   Failed" status.





(surname)               Expires October 01, 2012               [Page 14]

Internet-Draft                  Core-API                      April 2012


   Note that the Entity Tag specified in the response is generally
   specific to the actual payload included in the response.  If a REST
   service supports multiple representation formats for a single
   resource, such as offering multiple data format options or modified
   views of the resource tailored to the authentication credentials
   included in the request, the Entity Tag can vary for each specific
   response, regardless of whether the actual state of the resource on
   the server has changed.  Therefore, for any single resource, multiple
   Entity Tags can potentially represent the current state of the
   resource.

   At a minimum, all OpenSocial REST Services MUST support the If-Match,
   If-None-Match, If-Modified-Since and If-Unmodified-Since HTTP request
   headers for conditional requests.  All requests that result in the
   potential modification of the current state of a resource MUST
   include at least one of these request headers.

2.8.  Full vs.  Partial Modification

   The current state of a resource may be modified in part or in full
   using either the PATCH [RFC5789] or PUT HTTP methods, respectively.

   Given a URI that represents an resource, the current state of that
   resource can be modified in full by sending an HTTP PUT request to
   the URI. The payload of the PUT request is considered to be a
   replacement for the identified resource, although the server is free
   to determine exactly how the resource is to be modified.

   For example, suppose an application wishes to modify an existing
   profile that contains nothing more than a name and en email address.
   First, the application needs to GET the existing state of the profile
   so it can know what it is working with and can get the Entity Tag
   necessary for the PUT operation:

   GET /api/people/@me/@self HTTP/1.1

   The server responds with the profile:

     HTTP/1.1 200 OK
     Content-Type: application/json
     ETag: "ab12cd34ef56"
   
     {"name":{"displayName":"J. Doe"},
      "emails":[{"value":"john.doe@example.org"}]}

   The application wishes to modify this profile such that the name is
   expanded from "J. Doe" to "John Doe" and the email address is dropped
   completely.  The application can do so by sending the following PUT
   request:





(surname)               Expires October 01, 2012               [Page 15]

Internet-Draft                  Core-API                      April 2012


     PUT /api/people/@me/@self HTTP/1.1
     If-Match: "ab12cd34ef56"
     Content-Type: application/json
   
     {"name":{"displayName":"John Doe"}}

   Assuming the change is successful, the server would respond with an
   appropriate 2xx status, and MAY include the updated representation of
   the resource:

     HTTP/1.1 200 OK
     Content-Type: application/json
     ETag: "ab12cd34ef57"
   
     {"name":{"displayName":"John Doe"}}

   Alternatively, the application can use a PATCH request to perform a
   partial modification of the resource.  For instance, suppose the
   application needs to add an email address to the previously modified
   profile:

     PATCH /api/people/@me/@self HTTP/1.1
     If-Match: "ab12cd34ef57"
     Content-Type: application/json-patch
   
     [{"add":"/emails","value":{"value":"j.doe@example.com"}}]

   Assuming the change is successful, the server would respond with an
   appropriate 2xx status, and MAY include the updated representation of
   the resource:

     HTTP/1.1 200 OK
     Content-Type: application/json
     ETag: "ab12cd34ef57"
   
     {"name":{"displayName":"John Doe"},
      "emails":[{"value":"j.doe@example.com"}]
     }

   Support for the PATCH method to perform partial modifications of
   resource is optional.

2.8.1.  PATCH Document Formats

   OpenSocial REST Services that implement support for the PATCH
   operation MUST, at a minimum, support the use of the JSON Patch
   document format [I-D.ietf-appsawg-json-patch] for describing partial
   modifications and MAY support the use of the JSON Merge Patch
   mechanism as defined by section 3 of [I-D.snell-merge-patch].

   With JSON Patch, the payload of the HTTP PATCH request uses a simple
   JSON data structure to explicitly describe the changes being
   requested to the data.

(surname)               Expires October 01, 2012               [Page 16]

Internet-Draft                  Core-API                      April 2012


   For example, when working with an OpenSocial Person object, to change
   the value of a person's given name and add a new phone number, the
   request would be:

     PATCH /people/@me/@self HTTP/1.1
     Content-Type: application/json-patch
   
     [{"replace":"/name/givenName","value":"John"},
      {"add":"/phoneNumbers","value":{"label":"home","value":"123-123-1234"}]

   The advantage of using the JSON Patch format is that the requested
   changes are unamgibuous and clear, regardless of specific details of
   the implementation.

   If the JSON Patch document specifies any change that cannot be made,
   i.e.  it references a field that does not exist, or attempts to make
   a change that would cause the resulting data to be invalid in any
   way, the server MUST reject the PATCH request without making any
   changes to the target resource.

   As an alternative, the Merge Patch [I-D.snell-merge-patch] mechanism
   allows a client to requests partial modifications to be made by
   example.

   For example, given the following data object:

   {
     "displayName": "John Doe",
     "name" : {
       "givenName" : "John",
       "familyName" : "Doe"
     },
     "tags":["example","sample"]
   }

   If the intent is to change the value of the "displayName" property
   from "John Doe" to the value "J. Doe", add a new "phoneNumber"
   property, remove the "familyName" property from the "name" object,
   and remove the word sample from the "tags" Array, I would send the
   following request:

     PATCH /my/resource HTTP/1.1
     Host: example.org
     Content-Type: application/json+merge-patch; charset="UTF-8"
   
     {
       "displayName": "J. Doe",
       "phoneNumber": "+01-123-456-7890",
       "name": {
         "familyName": null
       }



(surname)               Expires October 01, 2012               [Page 17]

Internet-Draft                  Core-API                      April 2012

       "tags": ["example"]
     }

   Servers that support the Merge Patch mechanism MUST adhere to the
   rules specified in Section 3 of [I-D.snell-merge-patch] to determine
   the specific set of changes that is being requested.

   As with JSON Patch, if the Merge Patch request specifies any change
   that cannot be made for any reason, the server MUST reject the PATCH
   request without making any changes to the target resource.

   REST Services that support PATCH MUST advertise that support using
   the Accept-Patch HTTP Response header as defined by [RFC5789],
   Section 3.1

   For example,

   HTTP/1.1 200 OK
   Allow: GET, PUT, POST, DELETE, HEAD, PATCH, OPTIONS
   Accept-Patch: application/json-patch, application/json+merge-patch

2.9.  Error Handling

   When errors occur during the processing of a request sent to a REST
   service, the HTTP response will specify an appropriate error status
   identifying the general nature of the failure that occurred as well
   as any relevant specific detail.

   Errors in processing generally fall in to one of the following three
   categories:

   Functional Errors Typically occur when unforseen and unexpected error
      conditions arise on the server.  For instance, when there is no
      additional storage space available; when when a required service
      is unavailable.

   Request Validation Errors Typically occur when a request sent to a
      service is malformed in any way and cannot be processed; or when
      the request has not been properly authenticated.

   Business Rule Violations Typically occur when a request cannot be
      completed because doing so would violate some underlying business
      rule.  For instance, if a validly formed and properly
      authenticated request to change a property values on a particular
      resource to an invalid value type.

   When a Functional Error occurs during the processing of a request,
   server implementations MUST take cautions against inappropriately
   disclosing too much detail about the underlying implementation of the
   service.  Unless the user-agent submitting the request is considered
   to be a trusted entity by the server, error responses that represent
   Functional Errors SHOULD contain only a minimal amount of information



(surname)               Expires October 01, 2012               [Page 18]

Internet-Draft                  Core-API                      April 2012

   about the error.

   Function Errors are typically reported using 5xx Server Error
   response codes as defined in Section 7.5 of [I-D.ietf-
   httpbis-p2-semantics].

   The example response below communicates that the service is
   unavailable to process any requests and that the user agent can retry
   the request in two minutes:

   HTTP/1.1 503 Service Unavailable
   Retry-After: 120

   When a Request Validation Error occurs, the server MUST provide
   adequate detail in the response to indicate the nature of the
   validation failure.  Such errors can occur for a variety of reasons
   and are generally reported using 4xx Client Error response codes as
   defined in Section 7.4 of [I-D.ietf-httpbis-p2-semantics].  If a
   payload is included in the HTTP Response, then it SHOULD be a JSON
   document containing a single Error Object (Section 2.9.1) that
   describes the specific validation error that occurred.  A payload
   will not be required for all Request Validation Errors.  The choice
   of whether to include a payload describing the error for any
   particular request is left up to the server.

   The example response below indicates that the request was not
   properly authenticated and indicates that the user-agent must use
   OAuth 2.0 Bearer tokens to authenticate future requests.

   HTTP/1.1 403 Forbidden
   WWW-Authentication: Bearer realm="example"

   When Business Rule Violations occur, the server MUST provide adequate
   detail in the response to indicate the nature of the violation.  Such
   errors can occur for a variety of reasons are are generally reported
   using specific HTTP response codes such as 409 Conflict, 403
   Forbidden, or 400 Bad Request.  Such responses MUST contain a payload
   consisting of a single Section 2.9.1 that describes the specific
   violation.

   Business Rule Violations differ from other types of errors in that,
   typically, the request is properly formed and understood by the
   service, but was rejected for some other reason.  An example of such
   an error is when a particular user agent surpasses a preallocated
   number of requests within a given period of time.

   For example:








(surname)               Expires October 01, 2012               [Page 19]

Internet-Draft                  Core-API                      April 2012


     HTTP/1.1 403 Forbidden
     Content-Type: application/json
   
     {
       "code": -12345,
       "message": "Exceeded request quota"
     }

2.9.1.  The Error Object

   The Error object is a simple JSON data structure intended to
   communicate basic information about an error condition that has
   occurred.

   Error objects conform to all the same rules as all other OpenSocial
   Data Objects (Section 4), including extensibility characteristics.
   At a minimum, Error objects have the following properties:

   +----------+---------+----------------------------------------------+
   | Name     | Type    | Description                                  |
   +----------+---------+----------------------------------------------+
   | code     | Integer | A numeric code indicating the specific       |
   |          |         | nature of the error that occurred. When an   |
   |          |         | error object is included as the payload of   |
   |          |         | an HTTP response, this code MUST NOT be      |
   |          |         | interpreted as a replacement for the HTTP    |
   |          |         | response status code, which takes precedence |
   |          |         | and specifies the general status of the HTTP |
   |          |         | request. No standard error code values are   |
   |          |         | defined by this specification.               |
   | data     | Object  | A JSON object containing arbitrary           |
   |          |         | additional data about the error. The         |
   |          |         | specific properties of the object are        |
   |          |         | undefined.                                   |
   | message  | String  | A human readable and localized description   |
   |          |         | of the error that occurred. The value SHOULD |
   |          |         | NOT contain markup of any kind and SHOULD be |
   |          |         | interpreted as plain text.                   |
   +----------+---------+----------------------------------------------+

   When an error object is included as the payload of an HTTP message,
   the Content-Type header field, if specified, MUST specify a value of
   "application/json".

2.10.  Multiple resource and aspect operations

   For the GET, HEAD and OPTIONS HTTP methods, a REST service MAY
   support the ability for a user-agent to specify multiple local-
   identifiers and aspect-identifiers within a single request URI.
   There are, however, a number of important caveats and considerations




(surname)               Expires October 01, 2012               [Page 20]

Internet-Draft                  Core-API                      April 2012

   that need to be taken into consideration when working with multiple
   resources and multiple aspects within a single operation.

   To illustrate how the support for multiple resources works, consider
   a profile service that provides access to information about different
   users.  A user-agent can access the profiles of individual users by
   issuing a GET request to their respective URIs:

   GET /api/people/user-1/@self HTTP/1.1
   GET /api/people/user-2/@self HTTP/1.1
   GET /api/people/user-3/@self HTTP/1.1

   Each of these requests would return a single profile representations:

     HTTP/1.1 200 OK
     Content-Type: application/json
     ETag: "abcdef123456"
   
     {
       "id": "acct:user-1@example.org",
       "name": {"displayName": "John Doe"}
     }

   Using the multiple-resource capability, these three distinct HTTP
   requests can be combined into a single request:

   GET /api/people/user-1,user-2,user-3/@self HTTP/1.1

   This combined request would return each of the requested profiles
   within a single response consisting of a single top-level JSON object
   containing one property for each requested object, where the property
   key is the local-identifier of the resource:

     HTTP/1.1 200 Ok
     Content-Type: application/json
     ETag: "abcdefg123456"
   
     {
       "user-1": {
         "id": "acct:user-1@example.org",
         "name": {"displayName": "John Doe"}
       },
       "user-2": {
         "id": "acct:user-2@example.org",
         "name": {"displayName": "Jane Doe"}
       },
       "user-3": {
         "id": "acct:user-3@example.org",
         "name": {"displayName": "Sally Jones"}
       }
     }




(surname)               Expires October 01, 2012               [Page 21]

Internet-Draft                  Core-API                      April 2012


   If one of the requested resources does not exist, the server MAY
   choose to either reject the entire request with a 404 Not Found
   response or simply omit the missing item from the response or
   optionally include an explicit indicator that the specific item could
   not be found.

   For instance, if "user-3" does not exist, the following:

     HTTP/1.1 200 Ok
     Content-Type: application/json
     ETag: "abcdefg123456"
   
     {
       "user-1": {
         "id": "acct:user-1@example.org",
         "name": {"displayName": "John Doe"}
       },
       "user-2": {
         "id": "acct:user-2@example.org",
         "name": {"displayName": "Jane Doe"}
       },
       "user-3": null
     }

   Is equivalent to omitting the "user-3" property altogether:

     HTTP/1.1 200 Ok
     Content-Type: application/json
     ETag: "abcdefg123456"
   
     {
       "user-1": {
         "id": "acct:user-1@example.org",
         "name": {"displayName": "John Doe"}
       },
       "user-2": {
         "id": "acct:user-2@example.org",
         "name": {"displayName": "Jane Doe"}
       }
     }

   When the request specifies multiple aspect identifiers, the JSON
   object contained within the response will contain an additional layer
   of property values representing each individual aspect.

   For instance, if the user-agent wishes to retrieve both the profile
   and friends list for the current authenticated user, it could send a
   GET request to:

   GET /api/people/@me/@self,@friends




(surname)               Expires October 01, 2012               [Page 22]

Internet-Draft                  Core-API                      April 2012


   The response to this request would include a single top-level JSON
   object with properties for each of the requested aspects, whose
   values will be equivalent to what would have been returned had each
   aspect been requested by individual requests:

     HTTP/1.1 200 OK
     Content-Type: application/json
     ETag: "abcdefg1234567"
   
     {
       "@self": {
         "id": "acct:user-1@example.org",
         "name": {"displayName": "John Doe"}
       },
       "@friends": {
         "items": [
           {
             "id": "acct:user-2@example.org",
             "name": {"displayName": "Jane Doe"}
           },
           {
             "id": "acct:user-3@example.org",
             "name": {"displayName": "Sally Jones"}
           }
         ]
       }
     }

   When multiple local-identifiers and aspect-identifiers are specified,
   the construction of the returned JSON object is similarly nested:

   GET /api/people/user-1,user-2/@self,@friends






















(surname)               Expires October 01, 2012               [Page 23]

Internet-Draft                  Core-API                      April 2012


     HTTP/1.1 200 OK
     Content-Type: application/json
     ETag: "abcdefg1234567"
   
     {
       "user-1": {
         "@self": {
           "id": "acct:user-1@example.org",
           "name": {"displayName": "John Doe"}
         },
         "@friends": {
           "items": [
             {
               "id": "acct:user-2@example.org",
               "name": {"displayName": "Jane Doe"}
             },
             {
               "id": "acct:user-3@example.org",
               "name": {"displayName": "Sally Jones"}
             }
           ]
         }
       },
     "user-2": {
         "@self": {
           "id": "acct:user-2@example.org",
           "name": {"displayName": "Jane Doe"}
         },
         "@friends": {
           "items": [
             {
               "id": "acct:user-1@example.org",
               "name": {"displayName": "John Doe"}
             }
           ]
         }
       }
     }

   If the data that would normally be returned when requesting a
   particular local-identifier and aspect-identifier cannot be
   represented as JSON -- for instance, when requesting a hypothetical
   "@avatar" aspect for a particular profile that could return a binary
   image resource-- the value for the given item within the JSON
   response MUST specify the IRI of the specific individual item within
   a field named "$self".

   For instance:

   GET /people/api/@me/@self,@avatar HTTP/1.1
   Host: example.org



(surname)               Expires October 01, 2012               [Page 24]

Internet-Draft                  Core-API                      April 2012


     HTTP/1.1 200 OK
     Content-Type: application/json
     ETag: "abcdefg1234567"
   
     {
       "@self": {
         "id": "acct:user-1@example.org",
         "name": {"displayName": "John Doe"}
       },
       "@avatar": {
         "$self": "http://example.org/people/api/@me/@avatar"
       }
     }

   Filter segment and query string parameters included in the request
   URI apply to each of the individually requested resources just as if
   separate requests were sent to each resource.

   For instance, the request:

   GET /api/activity/user-1,user-2/@all/app-1,app-2/@tags/foo,bar?fields=id,title

   Is to be interpreted as: for users "user-1" and "user-2", return the
   id and title fields for all activities generated by applications
   "app-1" and "app-2" and tagged with "foo" or "bar".

   Authentication credentials included in the request MUST be valid and
   authorized for each of the individually requested resources or the
   entire request MUST be rejected using either a 401 Unauthorized or
   403 Forbidden response.

   Modification of multiple resources with a single operation, as well
   as the use of any unsafe and non-idempotent HTTP method is not
   allowed.  Any method other than GET, HEAD and OPTIONS sent to a
   request URI specifying multiple resources MUST fail with a response
   of 405 Method Not Supported

   When a request contains either a If-Modified-Since or If-Unmodified-
   Since request header, the server MUST determine if all of the
   requested resources or aspects adhere to the condition.  If even just
   one of the requested resources fails to meet the condition, the
   entire request MUST be rejected using a 406 Not Acceptable response.

   Implementations SHOULD place strict limits on the number of distinct
   resources and aspects that may be included within a single request
   URI.  When a user agent submits a request for too many resources or
   aspects, the server SHOULD return a 414 Request-URI Too Long
   response.

   If an implementation does not support the specification of multiple
   resources or aspects within a single request, a 404 Not Found
   response SHOULD be returned.


(surname)               Expires October 01, 2012               [Page 25]

Internet-Draft                  Core-API                      April 2012


2.11.  Operation Identifiers

   For the purpose of simplifying an interaction with various REST
   services, an OpenSocial implementation that provides Application
   Container Services (see [core-gadget]) can provide a layer of code
   that abstracts the REST service request and provides a simplified
   interface.

   In order to better facilitate interoperability within that
   abstraction layer, OpenSocial REST Services can specify a alias for
   each logical interaction the application can have with the service.
   Such aliases take the form:

   operation-identifier = service-identifier "." token

   For example, the OpenSocial Person Service provides operations that
   allow a user-agent to request information about specific people.
   When interacting directly with the REST Service, this request takes
   the form of an HTTP GET request:

   GET /api/people/@me/@self HTTP/1.1
   Host: example.org

   Within an OpenSocial Application hosted within an OpenSocial
   container (see [core-gadget]), this same operation can be referenced
   using the operation identifier "people.get":

   <Module>
     <ModulePrefs>
       ...
     </ModulePrefs>
     <Data>
       <os:DataRequest key="me" method="people.get" userId="@me" groupId="@self" />
     </Data>
     <Content type="html">
       ...
     </Content>
   </Module>

   Operation identifiers specific to each of the core OpenSocial REST
   Services are defined within the OpenSocial Social Applications
   Specifications [social-app].

3.  Dates, Times and Timezone Offsets

   Whenever date, time, timezone, duration or time period data is used
   anywhere within an OpenSocial implementation, the following rules
   MUST be applied.

   When encoding a Date and Time together, the date-time construct from
   [RFC3339] MUST be used.  In addition, an uppercase "T" character MUST
   be used to separate the date and time, and an uppercase "Z" character
   MUST be present in the absence of a numeric time zone offset.

(surname)               Expires October 01, 2012               [Page 26]

Internet-Draft                  Core-API                      April 2012


   For example:

   2012-11-09T12:32:34-08:00
   2013-03-23T01:23:43Z

   When encoding a Date, the full-date construct from [RFC3339] MUST be
   used.

   For example:

   2012-11-09

   When encoding a Time, either the partial-time or full-time constructs
   from [RFC3339] MUST be used.  When encoded as a full-time, an
   uppercase "Z" character MUST be present in the absence of a numeric
   time zone offset.

   For example:

   12:32:34-08:00 // full-time
   12:32:34       // partial-time

   When encoding a Timezone Offset, the time-offset construction from
   [RFC3339] MUST be used.  Note that when denoting a Timezone Offset
   equal to the Coordinated Universal Time (UTC), an uppercase "Z"
   character MUST be used.

   For example:

   -08:00

   When encoding a Duration, the duration construction from [RFC3339]
   MUST be used.

   For example:

   P3Y6M4DT12H30M5S

   When encoding a period of time, the period constructions from
   [RFC3339] MUST be used.  Note that when the period contains explicit
   date and time components, an uppercase "T" character MUST be used to
   separate the date and time, and an uppercase "Z" character MUST be
   used in the absence of a numeric time zone offset.

   For example:

   P1Y2M10DT2H30M/2008-05-11T15:30:00Z

4.  Data Objects





(surname)               Expires October 01, 2012               [Page 27]

Internet-Draft                  Core-API                      April 2012


   All Data Objects exposed via REST Services are serialized as JSON
   Objects as defined by [RFC4627].  Alternative serializations MAY be
   used but are considered outside the scope of this specification.
   Previous versions of OpenSocial allowed for Atom [RFC4287] and simple
   XML serializations that have now been deprecated.  Each of these are
   documented in the OpenSocial Deprecated Support Specification [TODO:
   Ref Doc].  Implementations MAY support the deprecated formats for
   backwards compatibility with existing applications.

   Unless otherwise stated in the definition of a specific property, the
   following general serialization rules apply:

   o  Absent properties MAY be represented either by an explicit
      declaration of the property whose value is null or by omitting the
      property declaration altogether at the option of the publisher;
      these two representations are semantically equivalent.  If a
      property is having a value whose type is a JSON array, the absence
      of any items in that array SHOULD be represented by omitting the
      property entirely or publishing it with the value null, and SHOULD
      NOT be represented as an empty array.

   o  Member values of an array value SHOULD be uniform in type.  That
      is, Array values SHOULD NOT contain a mix of primitive, array and
      object data types, for instance ""foo":["a","b","c"]" is
      acceptable while ""bar":["a",{"b":"c"},["d","e"]]" is not.

   o  When a property is defined as a boolean and the value is false,
      the property MAY be omitted entirely from the JSON serialization.

   o  When a property is defined as a "plural field", it's value MUST be
      serialized as an Array of Plural Objects as defined by Section
      4.2.

   o  All IRI [RFC3987] and URI [RFC3986] references contained with the
      serialized JSON structure SHOULD be absolute.  If relative URI and
      IRI references are used, and the serialized JSON is included
      within either an HTTP request or returned in response to an HTTP
      request, the references are to be resolved relative to either the
      HTTP Request URI or the value of the Content-Location response
      header, if one is included within the HTTP response.

   o  All dates, times, durations and periods of time are to be encoded
      as specified in Section 3.

   o  When a Data Object is defined as a "collection", it's value MUST
      be serialized as defined in Section 4.1.

4.1.  Collection Objects

   A "Collection Object" is a Data Object that represents a set of
   individual, related Data Objects.  Collection Objects are serialized
   as JSON Objects conforming to the JSON Activity Streams Collection
   construct as defined in Section 3.5 of [json-activity-streams].

(surname)               Expires October 01, 2012               [Page 28]

Internet-Draft                  Core-API                      April 2012


   Such serialized objects inherit all of the basic properties of the
   Activity Streams Collection object:

   +------------+-----------+------------------------------------------+
   | Name       | Type      | Description                              |
   +------------+-----------+------------------------------------------+
   | totalItems | JSON      | An optional, non-negative integer        |
   |            | Integer   | specifying the total number of items     |
   |            |           | within the collection. This number       |
   |            |           | SHOULD reflect the actual total number   |
   |            |           | of Data Objects that are considered to   |
   |            |           | be members of the set that can be        |
   |            |           | returned after applying any requested    |
   |            |           | filtering operations and not the number  |
   |            |           | of items actually serialized as values   |
   |            |           | in the "items" property value.           |
   | items      | JSON      | An array containing a listing of Data    |
   |            | Array     | Objects. This listing MAY be a subset of |
   |            |           | the total number of objects considered   |
   |            |           | to be members of the collection.         |
   | url        | JSON      | An optional IRI referencing a JSON       |
   |            | String    | Activity Streams document containing the |
   |            |           | full listing of objects within the       |
   |            |           | collection.                              |
   +------------+-----------+------------------------------------------+

   All other properties defined by the JSON Activity Streams
   specification for a Collection Object MAY be included in the
   serialization but their specific use and function is considered out
   of scope of this specification.

   This specification defines the following additional properties that
   MAY be used:





















(surname)               Expires October 01, 2012               [Page 29]

Internet-Draft                  Core-API                      April 2012


   +--------------+-----------+----------------------------------------+
   | Name         | Type      | Description                            |
   +--------------+-----------+----------------------------------------+
   | startIndex   | JSON      | A non-negative integer value that      |
   |              | Integer   | identifies the relative position       |
   |              |           | within the collection of the first     |
   |              |           | object contained in the items          |
   |              |           | property. For instance, if there are   |
   |              |           | 20 items that are considered to be     |
   |              |           | members of a collection, but only the  |
   |              |           | last 10 of those items are serialized  |
   |              |           | within the value of the "items"        |
   |              |           | property, the value of "startIndex"    |
   |              |           | would be 10.                           |
   | itemsPerPage | JSON      | A non-negative integer that specifies  |
   |              | Integer   | the maximum number of Data Objects     |
   |              |           | that will be serialized within the     |
   |              |           | value of the "items" property. The     |
   |              |           | actual number of items within the      |
   |              |           | "items" array SHOULD be equal to or    |
   |              |           | less than the value of the             |
   |              |           | "itemsPerPage" value.                  |
   +--------------+-----------+----------------------------------------+

   The following example shows a subset of a collection of OpenSocial
   Person objects:

   {
     "totalItems": 10,
     "startIndex": 0,
     "itemsPerPage" : 2,
     "items" : [
       {
        "displayName":"Joe",
        "name": {
          "givenName":"Joe",
          "familyName":"Smith"
        }
       },
       {
        "displayName":"Sally",
        "name": {
          "givenName":"Sally",
          "familyName":"Jones"
        }
       }
     ]
   }

4.1.1.  Multi-page Collections




(surname)               Expires October 01, 2012               [Page 30]

Internet-Draft                  Core-API                      April 2012


   Collections that consist of a large number of items can often be
   split into multiple documents, or pages, where each page contains a
   subset of the total number of items in the complete set as well as
   links to subsequent or preceding pages.

   Within a Collection object, links to pages are represented using the
   generalized Activity Streams Links mechanism described in [astream-
   links].  Specifically, the following table lists the additional
   optional Collection Object properties used to link multiple pages of
   a collection:

   +-------------+----------+------------------------------------------+
   | Name        | Type     | Description                              |
   +-------------+----------+------------------------------------------+
   | $first      | String   | A String value containing the absolute   |
   |             |          | IRI reference of the furthest preceding  |
   |             |          | page of the multi-page collection.       |
   | $last       | String   | A String value containing the absolute   |
   |             |          | IRI reference of the furthest following  |
   |             |          | page of the multi-page collection.       |
   | $previous   | String   | A String value containing the absolute   |
   |             |          | IRI reference of the immediately         |
   |             |          | preceding page of the multi-page         |
   |             |          | collection.                              |
   | $next       | String   | A String value containing the absolute   |
   |             |          | IRI reference of the immediately         |
   |             |          | following page of the multi-page         |
   |             |          | collection.                              |
   | $current    | String   | A string value containing the absolute   |
   |             |          | IRI reference of a page containing the   |
   |             |          | items that have been updated most        |
   |             |          | recently.                                |
   +-------------+----------+------------------------------------------+

   In order to be considered a paged collection, at least one of these
   properties MUST be present within the Collection object.

   For example,

   {
     "$first": "http://example.org/activities/@me/@all?count=10",
     "$next": "http://example.org/activities/@me/@all?count=10&updatedBefore=2012-12-12T12:12:12.123Z",
     "totalItems": 100,
     "items": [
       // .. list of items
     ]
   }







(surname)               Expires October 01, 2012               [Page 31]

Internet-Draft                  Core-API                      April 2012


   Note that consuming applications SHOULD treat the absolute IRI values
   used for paging as opaque identifiers and MUST NOT assume that they
   conform to any particular structure.  That said, it is expected that
   most implementations will use various combinations of the standard
   query string parameters (e.g.  count and startIndex, or count and
   updatedBefore) to construct paging links.

   When using a combination of the count and startIndex query parameters
   to facilitate paging of a collection whose items change or grow
   frequently over time, the process of splitting a collection into
   multiple pages can become "lossy".  That is, it is not possible to
   guarantee that consuming applications will be able to reconstruct the
   complete contents of the full collection at a particular time because
   items can be added or changed as the pages are accessed without the
   consuming application becoming aware of them.

   Such data loss can be avoided through the use of the updatedSince and
   updatedBefore parameters as an alternative to startIndex.  That is,
   rather than basing pages on the relative positioning of items within
   the overall collection, pages can be constructed to represent
   distinct periods of time (e.g.  the 30 entries updated before a given
   time; all entries updated within the last hour; etc).

4.2.  Plural Objects

   Within an OpenSocial Data Object, a "plural-field" is a property
   whose value consists of zero or more alternative choices represented
   as individual elements within a JavaScript Array.  Each choice is
   serialized as a JSON Object with at least the following basic
   properties:
























(surname)               Expires October 01, 2012               [Page 32]

Internet-Draft                  Core-API                      April 2012


   +---------+--------------+------------------------------------------+
   | Name    | Type         | Description                              |
   +---------+--------------+------------------------------------------+
   | label   | JSON String  | Provides a human-readable, plain-text,   |
   |         |              | and preferrably localized short          |
   |         |              | description of the object value suitable |
   |         |              | for display to a user.                   |
   | primary | JSON Boolean | A boolean value indicating whether a     |
   |         |              | particular plural object value is        |
   |         |              | considered to be the primary or          |
   |         |              | preferred alternative within the set. No |
   |         |              | more than one object in the array of of  |
   |         |              | objects specified as the value of a      |
   |         |              | plural field can have a "primary"        |
   |         |              | property of True.                        |
   | type    | JSON String  | Specifies a machine-processable label    |
   |         |              | for this object value that generally     |
   |         |              | identifies it's preferred function. For  |
   |         |              | instance, if the plural field represents |
   |         |              | a collection of phone numbers, the       |
   |         |              | "type" property value would specify      |
   |         |              | values such as "work", "home" or         |
   |         |              | "other", to differentiate each phone     |
   |         |              | number by purpose. Unlike the "label"    |
   |         |              | property which is intended for human-    |
   |         |              | readable display, the "type" property is |
   |         |              | intended to be used programmatically and |
   |         |              | MUST NOT utilize a localized value.      |
   | value   | JSON         | Represents the actual value of the       |
   |         | Primitive,   | object.                                  |
   |         | Array or     |                                          |
   |         | Object       |                                          |
   +---------+--------------+------------------------------------------+

   The example below shows a Data Object with a single plural-field
   providing alternative contact phone numbers for an individual.  Each
   is labeled, typed and a single number is marked as preferred:

















(surname)               Expires October 01, 2012               [Page 33]

Internet-Draft                  Core-API                      April 2012


   {
     "phoneNumbers": [
       {
         "value": "555-123-1234",
         "type": "home",
         "label": "Home"
       },
       {
         "value": "555-123-1235",
         "type": "work",
         "label": "Work",
         "primary": true
       },
       {
         "value": "555-123-1236",
         "type": "mobile",
         "label": "Mobile"
       }
     ]
   }

4.3.  Data Object Extensions

   This specification defines a core set of common Data Objects and an
   associated set of properties for each.  These properties comprise the
   core vocabulary of the OpenSocial Data Model.  Implementations are
   free to introduce extensions to this vocabulary so long as such
   extensions do not alter the semantics or requirements associated with
   any part of the core vocabulary.  Such extensions are referred to
   generically as "foreign properties".

   Note that future versions of this specification could introduce new
   properties and Data Objects to the core vocabulary.  Software written
   to conform to this version of the specification will not be able to
   process such properties correctly and, in fact, will not be able to
   distinguish it from other arbitrary types of extensions.  For the
   purpose of this discussion, unrecognized core vocabulary properties
   introduced by future versions of this specification will be
   considered to be "foreign properties".

   Implementations that encounter foreign properties within a Data
   Object MUST NOT stop processing or signal an error.  It might be the
   case that the implementation is able to process foreign properties
   correctly and does so.  Otherwise such properties are considered to
   be "unknown foreign properties".

   Whenever unknown foreign properties are encountered, implementations
   SHOULD ignore the properties and continue processing the Data Object
   as if they were not present.

   The values of extension properties SHOULD be serialized following the
   same rules specified for core vocabulary properties as defined in
   Section 4.

(surname)               Expires October 01, 2012               [Page 34]

Internet-Draft                  Core-API                      April 2012


4.3.1.  Avoiding Naming Conflicts

   Because foreign properties can be added at any time to a Data Object
   by multiple implementations, and because there is no centralized
   coordination of such extensions, there is a risk of conflicts arising
   when multiple implementations attempt to define foreign properties
   that share the same name.

   For example, imagine two separate vendor implementations that extend
   the basic OpenSocial Person Data Object to include data specific to
   each implementation.  For the sake of illustration, we will label
   these implementations as "foo.example.org" and "bar.example.com".
   Each defines a foreign property named "account" that while similar in
   purpose specify different types of values.

   In order to avoid conflicts between the two properties, each
   implementation SHOULD wrap each of their respective foreign
   properties into a single root extension property whose name is unique
   to the implementation and whose value is a JSON Object containing the
   set of foreign properties unique to that implementation.

   By convention, it is RECOMMENDED that the name of the root extension
   property follow the so-called "reverse-DNS" naming pattern.

   For example, the extended Person Data Object described above could be
   serialized as:

   {
     "displayName": "Joe",
     "org.example.foo": {
       "account": "joes-account"
     },
     "com.example.bar": {
       "account": {
         "id": "acct:joe@bar.example.com"
       }
     }
   }

   The JSON objects associated with each root extension property can
   contain any number of foreign properties, depending on the needs of
   the implementation, allowing all of the foreign properties specific
   to a particular implementation or serving a common purpose to be
   grouped together.

   By following this convention, implementations can protect themselves
   from conflicts with each other and with new properties that may be
   added by future versions of this specification.

4.4.  Data Object Type Identifiers




(surname)               Expires October 01, 2012               [Page 35]

Internet-Draft                  Core-API                      April 2012


   Every OpenSocial Data Object has an associated data type identifier
   in the form of an absolute IRI reference that is used in a number of
   different places throughout OpenSocial applications.  Such IRIs are
   used for identification purposes only and MUST be compared on a
   character-by-character basis in a case-insensitive fashion.

   All data type identifiers that begin with the prefix "http://
   opensocial.org/types/" are reserved for use by this specification.
   Implementations MUST NOT use any data type identifier that begins
   with the prefix "http://opensocial.org/types/" other than those
   defined by the OpenSocial specification.  Please refer to [social-
   app] for details on the current set of data types defined by
   OpenSocial.

4.4.1.  Legacy Data Type Identifiers

   Older versions of this specification utilized an alternative, now-
   deprecated syntax for data type identifiers:

   segment = 1*( ALPHA / DIGIT )
   prefix = segment "."
   name = segment
   legacy-datatype = prefix name

   For example, the legacy data type identifier for the OpenSocial
   Person datatype was "opensocial.Person".

   For backwards compatibility purposes with existing applications,
   implementations MAY continue to support the use of Legacy Data Types.
   New applications for which backwards compatibility is not a concern,
   however, SHOULD NOT use legacy data type identifiers.

5.  Security

   When a REST Service provides access to protected resources for which
   authentication is required, the service MUST support the use of
   either OAuth version 1.0a, OAuth version 2.0 or both as the preferred
   authentication mechanism.  Specific implementations MAY support
   additional alternative autentication mechanisms but support for such
   is considered out of the scope of this specification.

   REST Services MAY accept requests with no authentication or
   authorization information for data considered to be public.  The
   service MAY provide a limited "public representation" of a resource
   if no authorization information is provided in the request.

   In the case where no information is available due to lack of
   authorization, an HTTP 401 Unauthorized response SHOULD be returned
   to the client.  In the case where at least some view of the
   information is available, it SHOULD be returned using an appropriate
   2xx status, with a standard WWW-Authenticate response header
   indicating that additional information may be available when using a
   different authorization context.

(surname)               Expires October 01, 2012               [Page 36]

Internet-Draft                  Core-API                      April 2012


5.1.  OAuth 1.0a and 2.0 Support

   When utilizing the OAuth protocol, the overall flow is
   straightforward:

   o  The REST Service provider is the "resource server", providing
      access to one or more protected "resources" for which a "resource
      owner" MUST grant permission to access.

   o  Any application making use of a REST Service, is an OAuth "client"
      that MUST first acquire permission from the "resource owner" to
      access the resources provided by the server.

   o  Typically, the "resource owner" is the individual that is using
      the application and for which the application is attempting to
      access the resource.

   o  Once the client determines that it must access a protected
      resource, it must first acquire initial authorization.  How this
      is done depends entirely on what version and variation of the
      OAuth protocol is being used.  Generally, this step results in the
      granting of an "authentication token" to the client.

   o  Once the client has been authorized, it must ask the authorization
      server to exchange that authorization token for an access token.
      This access token, when granted, provides the client with
      permission -- limited in both time and scope -- to access the
      protected resource.  Because the access token allows the client to
      operate on behalf of the resource owner, the resource owner has to
      approve the exchange before the access token can be issued.  How
      the access token is issued depends entirely on what version and
      variation of the OAuth protocol is being used.

   o  Once the client has been granted an access token, it can use that
      token within it's requests to access the protected resource for a
      limited period of time.  Once the allotted time expires, the
      client must reacquire permission to continued access to the
      resource by requesting a new access token.

   There are several valid ways in which the initial authorization token
   may be acquired by the client.  This specification does not prescribe
   or require any single acquisition mechanism.

   Likewise, there are several valid ways in which an authenticated
   request can be prepared using the access token once acquired:

   o  When using OAuth 2.0, the access token can be included directly
      within the request utilizing the so-called "bearer token"
      mechanism defined by [I-D.ietf-oauth-v2-bearer] or the token can
      be combined with additional data to generate a cryptographic hash
      used for authentication purposes as described by [I-D.ietf-
      oauth-v2-http-mac].


(surname)               Expires October 01, 2012               [Page 37]

Internet-Draft                  Core-API                      April 2012


   o  When using OAuth 1.0a, the access token is utilized as described
      in Section 3.0 of [RFC5849].

   When utilizing OAuth version 2.0, all REST Services MUST, at a
   minimum, support the use of OAuth 2.0 Bearer Tokens as specified in
   [I-D.ietf-oauth-v2-bearer].  Because such tokens are passed to the
   server as unencrypted, plain text, all requests containing an OAuth
   2.0 Bearer Token MUST be exchanged using TLS 2.0 or SSL.

   All access tokens SHOULD be issued with limited scope and short
   expiration times to limit the risk of potential security breaches due
   to stolen access tokens.  The "scope" of an "access token" identies
   the range of resources and the types of operations for which the
   token can be used.  The "expiration time" specifies the length of
   time for which the access token is considered to be valid.  The token
   expiration policy is left to the specific implementation and may vary
   depending on the client requesting the token.  Expiration times of 1
   hour or less, and tokens with limited scope may be used with less
   trusted clients while expiration times of several hours and tokens
   with increased scope may be used for more trusted clients.
   Implementations SHOULD document (at least for administrators) how to
   configure token scopes and expiration times if these values are
   configurable.

5.2.  Signed Fetch

   All REST Services SHOULD support the use of the so-called "Signed
   Fetch" mechanism.

   Signed Fetch is a simplified mechanism based on a subset of the OAuth
   1.0a protocol that allows a container to "sign" requests sent to a
   remote endpoint.  Such signatures provide only a reasonable assurance
   that certain content contained within the request has not been
   modified by a malicious party.  Once a receiving endpoint determines
   that it is able to trust the signed request, it can decide to provide
   limited access to certain protected resources without having to walk
   through the entire typical OAuth protocol.

   Signed Fetch is described in detail in The OpenSocial Core Gadget
   Specification [core-gadget].

6.  Versioning

   The ability for server and client implementions to clearly
   communicate which version of the OpenSocial specification a
   particular Service API and resource supports is critical.

   For the purpose of clearly identifying which version of the
   OpenSocial specification a particular application is implementing, a
   Web Link header referencing the base URI of the OpenSocial
   specification and using a rel attribute value of "profile" [I-D
   .wilde-profile-link] SHOULD be included within the HTTP request and
   response message.

(surname)               Expires October 01, 2012               [Page 38]

Internet-Draft                  Core-API                      April 2012


   For example, the Link would appear within the request:

   GET /api/people/@me/@self HTTP/1.1
   Host: example.org
   Link: <http://opensocial.org/specs/3.0>; rel="profile"

   And within the response:

   HTTP/1.1 200 OK
   Link: <http://opensocial.org/specs/3.0>; rel="profile"

   A server MAY choose to implement additional conventions for
   identifying the current version, such as including a version
   indicator within the base URI of the Service API (e.g.  http://
   example.org/v3/api/people).  Such conventions are considered out of
   scope.

6.1.  Upgrade Indication and Transition

   When a server implementation of an older version of the OpenSocial
   specification upgrades to a newer version, it has the responsibility
   to provide a clear mechanism for either continuing to support client
   applications using the old version or help clients migrate to the
   new.  Whether a server chooses to continue to support the old and new
   versions of the OpenSocial specification simultaneously is an
   implementation and business decision that is out of the scope of this
   specification.  Accordingly, each of the options detailed below are
   informative in nature only.

   However, when a server wishes to indicate to a client application
   that the server has been upgraded and that the old version of the API
   is no longer available, it can do so using an Upgrade Required
   response.

   An "Upgrade Required Response" is an HTTP response that uses the 426
   Upgrade Required status along with an "profile" Web Link.  For
   instance:

   HTTP/1.1 426 Upgrade Required
   Upgrade: OpenSocial/3.0
   Connection: upgrade
   Link: <http://opensocial.org/specs/3.0>; rel="profile"

   When using such responses, the Upgrade header MUST specify an Upgrade
   Token value of "OpenSocial" and an Upgrade Version Token consisting
   of the major and minor version identifier as specified in Section 1.2
   of [core-gadget].







(surname)               Expires October 01, 2012               [Page 39]

Internet-Draft                  Core-API                      April 2012


   Use of the 426 Upgrade Required response implies a complete cutover
   from one version of the specification to another.  While such a
   strategy might be appropriate in some cases, many applications will
   require a more gradual approach in order to avoid breaking existing
   clients.  Alternatively, a server can choose to migrate client
   applications incrementally, initially deploying the new version of
   the application side-by-side with the old.

   For example, if a server currently exposes version 3.0 of the
   OpenSocial Person Service at the URI "http://example.org/api/people",
   and it wishes to upgrade clients to a hypothetical version 3.1 in the
   future, without requiring clients to change the URIs used to access
   the service, it can either continue to support the 3.0 clients
   transparently or perform an "in place" upgrade.

   An example 3.0 client request:

   GET /api/people/@me/@self HTTP/1.1
   Link: <http://opensocial.org/specs/3.0>; rel="profile"

   A server implementing a hypothetical 3.1 version of the OpenSocial
   spec can continue to respond as if it was a 3.0 implementation:

     HTTP/1.1 200 OK
     Link: <http://opensocial.org/specs/3.0>; rel="profile"
     Content-Type: application/json
   
     {... OpenSocial 3.0 data ...}

   Or, it can perform an "in-place" upgrade:

     HTTP/1.1 200 OK
     Upgrade: OpenSocial/3.1
     Connection: upgrade
     Link: <http://opensocial.org/specs/3.1>; rel="profile"
     Content-Type: application/json
   
     {... OpenSocial 3.1 data ...}

   Alternatively, the server MAY choose to deploy the new version with a
   new URI and redirect the down-level client to the new version of the
   application:

   An upgrade redirection from the server:

   HTTP/1.1 301 Moved Permanently
   Location: /v3.1/api/people/@me/@self HTTP/1.1
   Upgrade: OpenSocial/3.1
   Connection: upgrade
   Link: <http://opensocial.org/specs/3.1>; rel="profile"

7.  Registry of Service Identifiers


(surname)               Expires October 01, 2012               [Page 40]

Internet-Draft                  Core-API                      April 2012


   Every REST service is associated with a distinct service-identifier
   as defined by Section 2.2. The OpenSocial Social Applications
   Specification [social-app] defines the core set of services and their
   associated identifiers.

   Implementations are free to introduce additional services so long as
   each is identified by a unique service-identifier.  To promote
   interoperability across implementations, this specification
   establishes a Registry of Service Identifiers to be hosted and
   managed by the OpenSocial Foundation.  This registry shall contain
   known, commonly used service identifiers.  Whenever an implementor
   defines and deploys support for new services, the associated
   identifier SHOULD be added to the registry.

   Registrations require review by the OpenSocial community and are
   subject to the following rules:

   1.  A service identifier, once registered, stays registered forever.

   2.  The registration MUST name a responsible party for the
       registration.

   3.  The registration MUST name a point of contact.

   4.  The registration MAY name a set of specifications associated with
       the identifier.  Such specifications SHOULD be publicly
       available.

   The party responsible MUST submit the registration request via email
   to the mailing list for the OpenSocial Specification Community Group.
   After a period of 30-days following the date of the email request, if
   there are no expicit objections from members of the community in
   response to the registration, the request will be assumed to be
   automatically accepted.

8.  Registry of Aspect Identifiers

   For each distinctly-named REST Service (see Section 2.2), every
   individual data object can have zero or more individually
   identifiable aspects (see Section 2.4). The OpenSocial Social
   Applications Specification [social-app] defines the core set of
   services and their associated aspect identifiers.

   Implementations are free to introduce additional aspects for any
   service so long as each is identified by a unique aspect identifier.
   To promote interoperability across implementations, this
   specification establishes a Registry of Aspect Identifiers to be
   hosted and managed by the OpenSocial Foundation.  This registry shall
   contain known, commonly used aspect identifiers.  Whenever an
   implementor defines and deploys support for new aspects, the
   associated identifier SHOULD be added to the registry.



(surname)               Expires October 01, 2012               [Page 41]

Internet-Draft                  Core-API                      April 2012


   Registrations require review by the OpenSocial community and are
   subject to the following rules:

   1.  An aspect identifier, once registered, stays registered forever.

   2.  The registration MUST name a responsible party for the
       registration.

   3.  The registration MUST name a point of contact.

   4.  The registration MAY name a set of specifications associated with
       the identifier.  Such specifications SHOULD be publicly
       available.

   5.  The registration MUST name the service-identifier for which it is
       associated.

   The party responsible MUST submit the registration request via email
   to the mailing list for the OpenSocial Specification Community Group.
   After a period of 30-days following the date of the email request, if
   there are no expicit objections from members of the community in
   response to the registration, the request will be assumed to be
   automatically accepted.

9.  References

9.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3864]  Klyne, G., Nottingham, M. and J. Mogul, "Registration
              Procedures for Message Header Fields", BCP 90, RFC 3864,
              September 2004.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

   [RFC2026]  Bradner, S., "The Internet Standards Process -- Revision
              3", BCP 9, RFC 2026, October 1996.

   [RFC5234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234, January 2008.

   [RFC6570]  Gregorio, J., Fielding, R., Hadley, M., Nottingham, M. and
              D. Orchard, "URI Template", RFC 6570, March 2012.

   [RFC5789]  Dusseault, L. and J. Snell, "PATCH Method for HTTP", RFC
              5789, March 2010.

   [RFC5234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234, January 2008.

(surname)               Expires October 01, 2012               [Page 42]

Internet-Draft                  Core-API                      April 2012


   [RFC3986]  Berners-Lee, T., Fielding, R. and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, RFC
              3986, January 2005.

   [RFC3987]  Duerst, M. and M. Suignard, "Internationalized Resource
              Identifiers (IRIs)", RFC 3987, January 2005.

   [RFC3339]  Klyne, G.Ed.,  and C. Newman, "Date and Time on the
              Internet: Timestamps", RFC 3339, July 2002.

   [RFC5849]  Hammer-Lahav, E., "The OAuth 1.0 Protocol", RFC 5849,
              April 2010.

   [RFC4627]  Crockford, D., "The application/json Media Type for
              JavaScript Object Notation (JSON)", RFC 4627, July 2006.

   [json-activity-streams]
              Snell, J., Atkins, M., Norris, W., Messina, C., Wilkinson,
              M. and R. Dolin, "JSON Activity Streams 1.0", May 2011,
              <http://activitystrea.ms/specs/json/1.0/>.

   [I-D.wilde-profile-link]
              Wilde, E., "The 'profile' Link Relation Type", Internet-
              Draft draft-wilde-profile-link-01, April 2012.

   [I-D.ietf-httpbis-p1-messaging]
              Fielding, R., Lafon, Y. and J. Reschke, "HTTP/1.1, part 1:
              URIs, Connections, and Message Parsing", Internet-Draft
              draft-ietf-httpbis-p1-messaging-19, March 2012.

   [I-D.ietf-httpbis-p2-semantics]
              Fielding, R., Lafon, Y. and J. Reschke, "HTTP/1.1, part 2:
              Message Semantics", Internet-Draft draft-ietf-
              httpbis-p2-semantics-19, March 2012.

   [I-D.ietf-httpbis-p3-payload]
              Fielding, R., Lafon, Y. and J. Reschke, "HTTP/1.1, part 3:
              Message Payload and Content Negotiation", Internet-Draft
              draft-ietf-httpbis-p3-payload-19, March 2012.

   [I-D.ietf-httpbis-p4-conditional]
              Fielding, R., Lafon, Y. and J. Reschke, "HTTP/1.1, part 4:
              Conditional Requests", Internet-Draft draft-ietf-
              httpbis-p4-conditional-19, March 2012.

   [I-D.ietf-httpbis-p5-range]
              Fielding, R., Lafon, Y. and J. Reschke, "HTTP/1.1, part 5:
              Range Requests and Partial Responses", Internet-Draft
              draft-ietf-httpbis-p5-range-19, March 2012.

   [I-D.ietf-httpbis-p6-cache]



(surname)               Expires October 01, 2012               [Page 43]

Internet-Draft                  Core-API                      April 2012

              Fielding, R., Lafon, Y., Nottingham, M. and J. Reschke,
              "HTTP/1.1, part 6: Caching", Internet-Draft draft-ietf-
              httpbis-p6-cache-19, March 2012.

   [I-D.ietf-httpbis-p7-auth]
              Fielding, R., Lafon, Y. and J. Reschke, "HTTP/1.1, part 7:
              Authentication", Internet-Draft draft-ietf-
              httpbis-p7-auth-19, March 2012.

   [I-D.ietf-appsawg-json-patch]
              Bryan, P., "JSON Patch", Internet-Draft draft-ietf-
              appsawg-json-patch-01, March 2012.

   [I-D.snell-merge-patch]
              Snell, J., "The application/merge-patch Media Type",
              Internet-Draft draft-snell-merge-patch-00, March 2012.

   [I-D.ietf-oauth-v2-bearer]
              Jones, M., Hardt, D. and D. Recordon, "The OAuth 2.0
              Authorization Protocol: Bearer Tokens", Internet-Draft
              draft-ietf-oauth-v2-bearer-19, April 2012.

   [I-D.ietf-oauth-v2-http-mac]
              Hammer-Lahav, E., "HTTP Authentication: MAC Access
              Authentication", Internet-Draft draft-ietf-oauth-v2-http-
              mac-01, February 2012.

   [core-gadget]
              "OpenSocial Core Gadget Specification v3.0", April 2012,
              <../Core-Gadget.xml>.

   [social-app]
              "OpenSocial Social Application Specification 3.0", April
              2012, <../Core-API.xml>.

   [astream-links]
              Snell, J.M., "Links for Activity Streams", April 2012,
              <https://raw.github.com/activitystreams/json-activity-
              links/master/activity-streams-links.txt>.

9.2.  Informative References

   [RFC4287]  Nottingham, M.Ed.,  and R. Sayre, Ed., "The Atom
              Syndication Format", RFC 4287, December 2005.

Author's Address

   OpenSocial and Gadgets Specification Group
   
   Email: opensocial-and-gadgets-spec@googlegroups.com




(surname)               Expires October 01, 2012               [Page 44]
