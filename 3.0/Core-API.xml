<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='./OpenSocial.xslt' ?>
<?rfc toc="yes"?>
<?rfc-ext allow-markup-in-artwork="yes"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY rfc2616 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml'> 
  <!ENTITY rfc4918 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4918.xml'> 
  <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'> 
  <!ENTITY rfc3864 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3864.xml'>
  <!ENTITY rfc5226 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml'>
  <!ENTITY rfc2026 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2026.xml'>
  <!ENTITY rfc5234 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml'>
  <!ENTITY rfc6570 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6570.xml'>
  <!ENTITY rfc5789 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5789.xml'>
  <!ENTITY rfc5234 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml'>
  <!ENTITY rfc3987 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3987.xml'>
  <!ENTITY rfc3986 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
  <!ENTITY rfc3339 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml'>
  
  <!ENTITY part1 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-17.xml'>
  <!ENTITY part2 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p2-semantics-17.xml'>
  <!ENTITY part3 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p3-payload-17.xml'>
  <!ENTITY part4 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p4-conditional-17.xml'>
  <!ENTITY part5 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p5-range-17.xml'>
  <!ENTITY part6 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p6-cache-17.xml'>
  <!ENTITY part7 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p7-auth-17.xml'>
  <!ENTITY bearer PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-v2-bearer-18.xml'>
  <!ENTITY profile PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-wilde-profile-link-01.xml'>
  
  <!ENTITY mac PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-v2-http-mac-01.xml'>
  <!ENTITY jsonpatch PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-appsawg-json-patch-01.xml'>
  <!ENTITY mergepatch PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-snell-merge-patch-00.xml'>
  
  <!ENTITY astreams PUBLIC '' 'http://docs.opensocial.org/download/attachments/4358254/astreams.xml'>
  
  <!ENTITY socialapp PUBLIC '' 'bib/social-gadget.bibxml'>
  <!ENTITY coregadget PUBLIC '' 'bib/core-gadget.bibxml'>
  <!ENTITY astreamlinks PUBLIC '' 'bib/astream-links.bibxml'>
]>
<rfc ipr="full3978" docName="core.api.xml" >
  <front>
    <title abbrev="Core-API">OpenSocial Core API Specification 3.0</title>
    <author fullname="OpenSocial and Gadgets Specification Group">
      <address>
        <email>opensocial-and-gadgets-spec@googlegroups.com</email>
      </address>
    </author>
    <date month="April" year="2012" />
    <abstract>
      <t>TBD</t>
    </abstract>
  </front>
 
  <middle>
  
    <section title="Introduction">
    
      <t>TBD</t>
    
      <section title="Notation and Conventions">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in 
        <xref target="RFC2119">RFC2119</xref>.</t>  
        
        <t>Some sections of this specification are illustrated with fragments
        of a <xref target="RFC5234">Augmented Backus-Naur Form</xref> (ABNF) grammar.
        The rules specified are normative.</t>
        
        <t>This specification allows the use of <xref target="RFC3987">IRIs</xref>. 
        Every <xref target="RFC3986">URI</xref> is also an IRI, so a URI may be 
        used wherever an IRI is named. There are two special considerations: 
        (1) when an IRI that is not also a URI is given for dereferencing, 
        it MUST be mapped to a URI using the steps in Section 3.1 of RFC 3987.
        and (2) when an IRI is serving as an identifier, it MUST NOT be 
        so mapped.</t>       
      </section>
    
    </section>
    
    <section title="REST Services">

      <t>OpenSocial REST Services consist of collections of Web-accessible
      resources that can be accessed and modified using the basic set of 
      HTTP request methods as defined by <xref target="I-D.ietf-httpbis-p2-semantics"/>.
      Such services are intended to be used either by OpenSocial Applications
      as defined by <xref target="core-gadget"/> or other third parties to
      access social data hosted and managed by an OpenSocial-enabled server.</t>
 
      <t>In general, for all REST Services:
      <list>
        <t>the HTTP GET method is used to retrieve representations
        of the current state of a any given resource,</t>
        <t>PUT and PATCH are used to modify the current state,</t>
        <t>DELETE is used to delete the resource,</t>
        <t>and POST is used to either create new resources or to perform 
        other types of operations that do not fit within the scope of the
        other core HTTP methods.</t>
      </list></t>
      
      <t>Implementations are free to support additional HTTP methods but 
      their use is considered to be outside the scope of this specification.</t>
      
      <t>Resources made available via a REST Service can represent
      individual objects (e.g. a person, a document, an activity) or 
      collections of objects (e.g. a friends list, a folder containing 
      multiple files, a listing of events). Every resource is identified 
      by a distinct URI to which the various HTTP methods are to be sent.</t>
 
      <figure><preamble>For example, to retrieve a user's current profile using
      the OpenSocial Person Service, a client application would issue a 
      GET request:</preamble><artwork type="example" xml:space="preserve">
  GET /api/people/@me/@self HTTP/1.1
  Host: api.example.org
      </artwork></figure>
      
      <t>When a client application is required to communicate with an 
      OpenSocial server via an intermediary that restricts the use of certain 
      standard and extension HTTP Methods (e.g. PUT, DELETE, PATCH),
      the client SHOULD utilize the <spanx style="verb">X-HTTP-Method-Override</spanx> 
      HTTP Request Header mechanism in a POST request.</t>
      
      <figure><preamble>For example, the HTTP PATCH request method is still 
      relatively new and is not yet fully supported by deployed HTTP infrastructure.
      It is therefore possible that PATCH requests might be blocked by 
      certain intermediaries. To address such cases, the PATCH request may be
      modified by sending a POST request that includes the 
      <spanx style="verb">X-HTTP-Method-Override</spanx> HTTP header:</preamble><artwork>
  POST /api/people/@me/@self HTTP/1.1
  Host: api.example.org
  Content-Type: application/json
  X-HTTP-Method-Override: PATCH

  {...}
      </artwork></figure>
      
      <t>OpenSocial Servers MUST respond to such requests as if the method 
      specified by the <spanx style="verb">X-HTTP-Method-Override</spanx> was 
      the actual operation used by the request, as opposed to POST.</t>
      
      <t>The <spanx style="verb">X-HTTP-Method-Override</spanx> header MUST NOT 
      be used to send HTTP GET requests.</t>
      
      <t>Responses to all requests will specify an appropriate HTTP Status Code
      indicating the status of the response.</t>
            
      <section title="Common URI Structure" anchor="uri-structure">
      
        <t>All REST Services share a common, basic URI Structure that MAY be 
        extended on a case-by-case basis. This common structure helps to ensure 
        that all interactions remain as consistent as possible across multiple 
        REST Services while allowing individual service-specific and implementation
        specific behaviors to be supported.</t>
        
        <figure><preamble>By convention, the Common URI Structure is described using a 
        <xref target="RFC6570">URL Template</xref>:</preamble><artwork>
  {protocol}://{+host}{/rootpath*,service-identifier,local-identifier,aspect-identifier,filters*}{?parameters*}
        </artwork></figure>
      
        <texttable>
          <ttcol>Expression</ttcol>
          <ttcol>Description</ttcol>
          
          <c>protocol</c>
          <c>Indicates either "http" or "https" depending on whether or 
          not SSL or TLS is to be used with the request.</c>
          
          <c>host</c>
          <c>Specifies the DNS Host Name and, if necessary, the TCP/IP 
          port at which the REST service is available. For instance, 
          "api.example.org" or "api.example.org:8080".</c>
          
          <c>rootpath</c>
          <c>Specifies the root path of the REST Service. The value is 
          specified as an Array of isegment-nz path segments as defined
          by <xref target="RFC3987"/>. For example, ["services","api"],
          which when expanded by the URL Template produces "/services/api".</c>
          
          <c>service-identifier</c>
          <c>The service identifier as defined by <xref target="service-identifiers"/>.</c>
          
          <c>local-identifier</c>
          <c>The local-identifier of a data object, as defined by 
          <xref target="object-identifiers"/> that is the target of 
          an HTTP request.</c>
          
          <c>aspect-identifier</c>
          <c>An aspect-identifier, as defined by <xref target="aspect-identifiers"/>,
          that identifies the specific aspect of the identified Data Object
          to which the HTTP request is being directed. For instance, if the 
          intent of the request is to retrieve the list of other people 
          connected to a particular user's profile, the local-identifier
          specifies the target user's local-identifier and the aspect-identifier
          would specify "@friends".</c>
          
          <c>filters</c>
          <c>A set of zero or more service, resource and aspect specific path
          segments that specify additional filters for the request (see 
          <xref target="filters"/>). The value is specified as an Array, each 
          member of which can either be an isegment-nz path segment or an Array 
          of isegment-nz path segments. For instance, the value ["a","b","c"] 
          would expand within the URL Template to "/a/b/c"; whereas the value 
          ["a",["b","c"]] would expand to "/a/b,c".</c>
          
          <c>parameters</c>
          <c>Specifies a collection of query parameters associated with the
          request, specified as a collection of name and value pairs. All REST
          Services are required to support a common core collection of 
          query parameters as defined in <xref target="standard-query-parameters"/>
          and MAY introduce additional service, resource and aspect specific
          parameters.</c>
          
        </texttable>
        
        <t>To illustrate how the common URI structure operates, consider the 
        following example. For each of the URI Template variables, assume
        the following values:
          <texttable>
            <ttcol>Variable</ttcol>
            <ttcol>Value</ttcol>
            <c>protocol</c>
            <c>https</c>
            <c>host</c>
            <c>api.example.org</c>
            <c>rootpath</c>
            <c>["service","api"]</c>
            <c>service-identifier</c>
            <c>people</c>
            <c>local-identifier</c>
            <c>@me</c>
            <c>aspect-identifier</c>
            <c>@friends</c>
            <c>filters</c>
            <c>["@recent"]</c>
            <c>parameters</c>
            <c>{"count":"10", "updatedAfter":"2012-04-16T00:00:00Z"}</c>
          </texttable>
        </t>
        
        <t>When applied to the common URI Template, the Request URI Generated
        becomes: "https://api.example.org/service/api/people/@me/@friends/@recent?count=10&amp;updatedAfter=2012-04-16T00:00:00Z".</t>
      
      </section>
      
      <section title="Service Identifiers" anchor="service-identifiers">
        
        <t>Service Identifiers are simple text labels, conforming to the
        isegment-nz construction defined in <xref target="RFC3987"/>,
        used to identify an individual OpenSocial REST service.</t>
          
        <figure><artwork>
  service-identifier = isegment-nz
        </artwork></figure>
        
        <t>For instance, the OpenSocial Person Service is identified using
        the label "people" while the Activity Stream Service is identified
        using the label "activity".</t>
        
        <figure><preamble>An example request to retrieve a person's profile
        using the Person Service:</preamble>
        <artwork>
  GET /service/api/people/@me/@self HTTP/1.1
  Host: example.org
        </artwork></figure>
        
        <figure><preamble>An example request to retrieve an Activity Stream
        associated with a person using the Activity Stream Service:</preamble>
        <artwork>
  GET /service/api/activity/@me/@all HTTP/1.1
  Host: example.org
        </artwork></figure>
        
        <t>Please refer to the <xref target="social-app"/> specification for 
        complete details on the core set of social data services defined by
        this version of the OpenSocial specification. Implementations are 
        free to implement additional services.</t>
        
        <t>If a particular implementation does not support a given specified
        service, it SHOULD simply return a 404 Not Found response.</t>
          
      </section>
      
      <section title="Local Identifiers" anchor="object-identifiers">

        <t>Every individual data object managed and made available via 
        a REST service is uniquely identified within that service's 
        context by a local-identifier.</t>
          
        <t>The local identifier is an opaque String conforming to the 
        isegment-nz construction of <xref target="RFC3987"/>. This string
        unique identifies the object within the context of the service
        with which the object is associated.</t>
          
        <figure><artwork>
  local-identifier = isegment-nz
        </artwork></figure>
          
        <section title="The &quot;@me&quot; Alias">
          
          <t>The literal string value "@me" MAY be used as an alias for the 
          local-identifier of the currently authenticated entity.</t>
            
          <t>For instance, if a person uses the OpenSocial Person Service to 
          request information about their own social data profile, the request 
          URI can specify the "@me" alias as opposed to the requester's 
          local-identifier. The server fullfilling the request would use the 
          requests authentication context to determine the appropriate 
          local-identifier.</t>

        </section>
        
        <section title="The &quot;@anonymous&quot; Alias">
        
          <t>The literal string value "@anonymous" MAY be used as an alias 
          for the local-identifier of any anonymous, non-authenticated entity.</t>

          <t>Previous versions of this specification used the numeric integer
          value -1 (negative one) to identify anonymous, non-authenticated users. 
          The use of the numeric integer is considered to be deprecated and 
          SHOULD NOT be used; however implementations MAY continue to support 
          the use of -1 in order to maintain backwards compatibility with 
          older applications.</t>

        </section>
        
        <section title="The &quot;@public&quot; Alias">
        
          <t>The literal string value "@public" is provided as a local-identifier
          identifying the total collection of "public" resources provided by 
          a REST service. For instance, if a requesting application wishes to
          use the OpenSocial Activity Service to retrieve a listing of all 
          recent public Activities that have occurred independent of the specific
          person or resource with which those activities are associated, the 
          request URI can specify "@public" as the local-identifier.</t>
          
          <t>The &quot;@public&quot; alias might not be supported by all 
          REST services or implementations.</t>
        
        </section>
          
        <section title="Legacy Global Identifiers">
          
          <t>Previous versions of this specification utilized an older 
          form of "global identifier" that has since been deprecated.
          Server implementations MAY continue to support the older 
          format for backwards-compatibility purposes with existing 
          applications but new applications SHOULD NOT make use of the 
          deprecated syntax.</t>
            
          <t>The legacy syntax consisted of a combination of a DNS
          domain name and an object's local identifier separated by 
          a colon (":") character.</t>
            
          <figure><artwork>
  domain-name = *( ALPHA / DIGIT / "_" / "." / "-" )
  legacy-global-identifier   = domain-name ":" local-identifier
          </artwork></figure>
            
        </section>      
      </section>
      
      <section title="Aspect Identifiers" anchor="aspect-identifiers">
      
        <t>Every type of Data Object provided by a REST service can have
        zero or more distinct aspects to which requests can be directed.
        These aspects are always specific to the individual type of resource
        and service. Aspects are identified within the URL structure using an 
        aspect-identifier.</t>
        
        <figure><artwork>
  aspect-identifier = "@" isegment-nz
        </artwork></figure>
        
        <t>For example, Person Data Objects as defined by the <xref target="social-app"/>
        expose a number of Aspects that are specific to the social data that 
        makes up a person's profile data. For instance:
          <list style="symbols">
            <t>There is the "@self" Aspect that references the person's own 
            profile detail (i.e. their name, contact information, interests, etc);</t>
            <t>The "@friends" Aspect that references the person's 
            network of directly connected friends and associates;</t>
            <t>The "@network" Aspect that references the person's
            extended network (i.e. friends-of-friends, etc).</t>
          </list>
        </t>
        
        <figure><preamble>To retrieve information about specific aspects, the 
        appropriate aspect-identifier would be included in the request URI.</preamble>
        <artwork>
  GET /service/api/people/@me/@self HTTP/1.1
  Host: example.org
  
  GET /service/api/people/@me/@friends HTTP/1.1
  Host: example.org
  
  GET /service/api/people/@me/@network HTTP/1.1
  Host: example.org
        </artwork></figure>
        
        <t>Please refer to <xref target="social-app"/> for complete details on 
        the specific aspects associated with each of the core OpenSocial Social 
        Data Objects and services. Implementations are free to define additional 
        aspects for any of the core Social Data Objects and Services.</t>
        
        <t>To prevent against the likelihood of compatibility issues arising 
        through the use and extension of aspects by implementations as well 
        to promote the reuse and socialization of new aspect-identifiers, this 
        document establishes a <xref target="aspect-identifier-registry">registry 
        of common aspect identifiers.</xref> It is RECOMMENDED that all 
        aspect-identifiers used within OpenSocial implementations be added to
        the registry per the requirements detailed in 
        <xref target="aspect-identifier-registry"/>.</t>
        
        <t>If a particular implementation does not support a given specified
        aspect, it SHOULD simply return a 404 Not Found response.</t>
      
      </section>
      
      <section title="Filters" anchor="filters">
      
        <t>The Common URI Structure also supports the use of service, data object
        and aspect specific filters that can be used to further define the scope
        of a particular REST request. When expressed within the request URI,
        such filters take the form of an arbitrary set of additional isegment-nz 
        path segments.</t> 
        
        <t>Implementations MAY choose to allow multiple filter 
        identifiers separated by a comma (,) character within a single path 
        segment. When multiple, comma-separated filter identifiers are specified,
        they are to be interpreted as distinct alternatives (e.g. the filter 
        segment "a,b" is to be interpreted as "a or b" as opposed to "a and b").</t>
        
        <figure><artwork>
  filter = isegment-nz
        </artwork></figure>
        
        <t>For example, an application that is requesting a listing of 
        Activity Objects provided by the OpenSocial Activity Stream service
        may wish to limited the returned set of activities to only those 
        generated by particular applications. To do so, the application 
        would identify the applications using filter segments:</t>
        
        <figure><artwork>
  GET /service/api/activity/@me/@all/app-1,app-2
  Host: example.org
        </artwork></figure>
        
        <t>Alternatively, an implementation can choose to allow applications
        to limit the results returned by the request to only those that have
        been "tagged" with a particular label. This is strictly an non-normative
        example illustrating the basic function of filters as "tagging" of 
        Data Objects is not defined by this specification:</t>
        
        <figure><artwork>
  GET /service/api/activity/@me/@all/@tags/foo,bar
        </artwork></figure>
        
        <t>When an implementation supports and applies filters, they MUST be 
        interpreted as a hierarchy, with each subsequent path segment being 
        interpreted relative to the previous segment. The exact application 
        of the filters is left to the implementation, however.</t>
        
        <t>For example, given the hypothetical request:</t>
        
        <figure><artwork>
  GET /service/api/activity/@me/@all/app-1,app-2/@tags/foo,bar
        </artwork></figure>
        
        <t>The appropriate way to interpret this request is: Return the 
        list of all activities for the authenticated user generated by 
        either app-1 or app-2 that have been tagged with either "foo" or 
        "bar".</t>
        
        <t>Please refer to <xref target="social-app"/> for complete detail on 
        specific filters associated with each of the core OpenSocial Social Data 
        Objects and services. Implementations are free to define additional 
        filters for any of the core Social Data Objects and Services.</t>
      
        <t>If a particular implementation does not support a given specified
        filter, it SHOULD simply return a 404 Not Found response.</t>
      
      </section>
      
      <section title="Standard Query Parameters" anchor="standard-query-parameters">
        <t>All REST services MUST support a common set of URI Query
        String parameters that can be used to modify the processing of the 
        request and the information returned to the client.</t>
        
        <texttable>
        
          <ttcol>Name</ttcol>
          <ttcol>Description</ttcol>
          
          <c>count</c>
          <c>When the resource to which a request is directed represents a 
          collection of items and the intention of the request is to retrieve
          a listing of a subset of those items, the count value specifies the 
          maximum number of items to return. The value is specified as a 
          non-negative integer. If unspecified, the server is free to determine
          a reasonable default value. No default value is assumed. If a value 
          of zero (0) is specified then it is to be interpreted as a request 
          for an empty collection. If any value other than a non-negative
          integer value is specified, the parameter SHOULD be ignored as if the 
          parameter were not present at all.</c>
          
          <c>fields</c>
          <c>The fields parameter allows a client application retrieving 
          information about a resource to specify individual pieces of 
          information it is interested in receiving as a simple, comma separated 
          list. For instance, "fields=name,email". The server MAY choose to 
          return a representation of the requested information containing only 
          the requested fields along with any additional information the server 
          determines is required. If the resource identified by the URI 
          represents a collection of individual objects, the fields parameter 
          identifies the requested properties of those individual objects, 
          rather than the properties of the collection.</c>
        
          <c>filterBy</c>
          <c>When the resource to which a request is directed represents a
          collection of items and the intention of the request is to retrieve
          a subset of those items, the filterBy parameter specifies the name
          of a field to be used as a selection filter to determine the subset
          of items to return. The value of the parameter is the name of a
          field contained by each of the objects in the collection. This property 
          is intended to be used in conjunction with the filterOp and 
          filterValue parameters.</c>
        
          <c>filterOp</c>
          <c>When the filterBy parameter is used to specify the name of a field
          to use as a selection filter, the filterOp parameter is used to specify
          the specific type of selection filter operation to apply. Possible 
          values are:
            <list style="hanging">
              <t hangText="contains">
                Indicates that the value of the field identified by the filterBy
                parameter MUST contain the exact value specified by the filterValue
                parameter.
              </t>
              <t hangText="equals">
                Indicates that the value of the field identified by the filterBy
                parameter MUST equal the exact value specified by the filterValue
                parameter.
              </t>
              <t hangText="startsWith">
                Indicates that the value of the field identified by the filterBy
                parameter MUST begin with the exact characters specified by the 
                filterValue parameter.
              </t>
              <t hangText="present">
                Indicates that items are only considered to match the selection
                filter if the field identified by the filterBy parameter is present
                within the item and specifies a non-null value. When filterOp
                equals "present", the filterValue parameter is ignored.
              </t>
            </list>
          </c>
          
          <c>filterValue</c>
          <c>When using the filterBy and filterOp parameters, and filterOp 
          equals "contains", "equals" or "startsWith", the filterValue parameter
          specifies the value against which the value of the filterBy field 
          is tested.</c>
        
          <!-- TODO: Move to deprecated document
          <c>format</c>
          <c>By default, all REST services utilize the JSON-based serialization
          defined in <xref target="data-representation"/>. Individual services A
          MAY support additional data serializations on a case-by-case
          basis. Client applications SHOULD use existing user agent or server
          driven Content Negotiation mechanisms such as the Accept request header 
          (e.g. "Accept: application/atom+xml") to identify specific
          preferred data formats. However, as not all requesting applications are 
          capable of directly accessing HTTP Headers, the "format" parameter 
          MAY be used as an alternative. The value of the format parameter is 
          a single MIME Media Type, e.g. "format=application/atom+xml".</c>
           -->
          
          <c>sort</c>
          <c>When the resource to which a request is directed represents a 
          collection of items and the intention of the request is to retrieve
          a listing of those items, the sort parameter specifies one or more 
          fields to be used as a sorting index and the order in which items
          SHOULD be returned. The value is a comma separated list of sort-key
          definitions as specified in <xref target="sort-parameter"/>.</c>
          
          <!-- Move to deprecated
          <c>sortOrder</c>
          <c>When the resource to which a request is directed represents a 
          collection of items and the intention of the request is to retrieve
          a listing of those items, the sortOrder parameter specifies the 
          sorting order in which those items will be returned. The value is 
          specified as one of either "ascending" or "descending". TODO: need a sort key</c>
          -->
          
          <c>startIndex</c>
          <c>When the resource to which a request is directed represents a 
          collection of items and the intention of the request is to retrieve
          a subset of those items, the startIndex parameter specifies the 
          relative position of the first item to return out of the total set 
          of items that can be returned as determined by the server after any 
          requested filtering and sorting of the set as been applied. The index 
          is 0-based such that to return the first item of the set, the 
          startIndex parameter value would be 0. </c>
          
          <c>updatedSince</c>
          <c>When the resource to which a request is directed represents a 
          collection of items and the intention of the request is to retrieve
          a subset of those items, the updatedSince parameter specifies that
          the server SHOULD only return items that have been updated after a
          given date and time. The value is expressed as an RFC 3339 date-time
          as described in <xref target="datetimes"/>.</c>
          
          <c>updatedBefore</c>
          <c>When the resource to which a request is directed represents a 
          collection of items and the intention of the request is to retrieve
          a subset of those items, the updatedBefore parameter specifies that
          the server SHOULD only return items updated before the given date 
          and time. The value is expressed as an RFC 3339 date-time as described
          in <xref target="datetimes"/>.</c>
        
        </texttable>
        
        <section title="The Sort Parameter" anchor="sort-parameter">
        
          <t>The value of the <spanx style="verb">sort</spanx> parameter 
          is a comma-separated list of sort-keys as defined below.</t>
          
          <figure><artwork>
  sort-default-order = field
  sort-default-field = "+" / "-"
  sort-order-field = ("+" / "-") field
  sort-key = sort-default-order / sort-default-field / sort-order-field
          </artwork></figure>
          
          <t>Each sort-key consists of an optional ASCII plus (+) or minus (-)
          character that indicates the requested sorting order -- where plus 
          indicates ascending and minus indicates descending -- and the name 
          of a field to sort by.</t>
          
          <t>For instance, to request that the items of the collection be 
          returned in reverse chronological order by the date and time they 
          were last updated, assuming each item in the collection has an 
          "updated" field, the value of the sort parameter would be: 
          <spanx style="verb">sort=-updated</spanx>.</t>
          
          <t>Multiple sort-keys MAY be specified. For instance, to request
          that the items of the collection be returned in reverse chronological
          order by the date and time they were last updated, but in alphabetical
          order by the title field, the value of the sort parameter would be:
          <spanx style="verb">sort=-updated,+title</spanx>.</t>
          
          <t>If the optional plus or minus indicator is omitted, the server 
          shall determine an appropriate default sorting order.</t>
          
          <t>If the sort parameter specifies a field that is unsupported for
          the type of objects within the collection, the unsupported field
          MUST be ignored.</t>
        
        </section>
        
      </section>
      
      <section title="Conditional Requests">
      
        <t>All REST services MUST support the use of Conditional
        Request mechanisms as defined in 
        <xref target="I-D.ietf-httpbis-p4-conditional"/>.</t>
          
        <t>When returning the current representation of any resource, whether 
        that representation is for a single object or a collection of objects,
        the HTTP Response MUST include either a strong Entity Tag as defined
        in Section 2.3 of <xref target="I-D.ietf-httpbis-p4-conditional"/>, a 
        Last-Modified Timestamp as specified in Section 2.2, or both.</t>
          
        <figure><preamble>For example, the response to a request retrieving
        the current representation of a person's profile might include both
        an Entity Tag and a Last-Modified timestamp:</preamble><artwork>
  HTTP/1.1 200 OK
  Content-Type: application/json
  ETag: "ab12cd34ef56"
  Last-Modified: Tue, 15 Nov 2012 12:45:26 GMT
        </artwork></figure>
  
        <t>Once a client has the Entity Tag or Last-Modified timestamp for 
        a given resource representation, subsequent requests SHOULD utilize
        one or the other within a conditional request to optimize communication 
        and to ensure that multiple clients do not inadvertently overwrite each 
        other's data.</t>
        
        <figure><preamble>For instance, given the Last-Modified Timestamp 
        included in a response to a request to receive a user's profile, a 
        client can request that the server return an updated view of the 
        profile if, and only if the state of the profile has changed since 
        the specified time:</preamble><artwork>
  GET /api/people/@me/@self HTTP/1.1
  If-Modified-Since: Tue, 15 Nov 1994 12:45:26 GMT
        </artwork></figure>
  
        <t>If the profile has not been modified since the date specified, the 
        server would respond with a "304 Not Modified" status.</t>
      
        <figure><preamble>Given the Entity Tag of a resource representation, 
        a client wishing to modify the resource can request that changes only 
        be applied if the resource has not been subsequently modified since 
        the original representation and Entity Tag were created:</preamble><artwork>
  PUT /api/people/@me/@self HTTP/1.1
  If-Match: "ab12cd34ef56"
  Content-Type: application/json 
  
  {...}
        </artwork></figure>
      
        <t>If the server is unable to determine that the specified Entity 
        Tag applies to the current state of the resource, it will abort the 
        change request and respond to the request using a "412 Precondition 
        Failed" status.</t>
  
        <t>Note that the Entity Tag specified in the response is generally 
        specific to the actual payload included in the response. If a REST 
        service supports multiple representation formats for a single resource, 
        such as offering multiple data format options or modified views of the 
        resource tailored to the authentication credentials included in the 
        request, the Entity Tag can vary for each specific response, regardless 
        of whether the actual state of the resource on the server has changed. 
        Therefore, for any single resource, multiple Entity Tags can potentially 
        represent the current state of the resource.</t>
        
        <t>At a minimum, all OpenSocial REST Services MUST support the If-Match, 
        If-None-Match, If-Modified-Since and If-Unmodified-Since HTTP request 
        headers for conditional requests. All requests that result in the 
        potential modification of the current state of a resource MUST include 
        at least one of these request headers.</t>
      
      </section>
      
      <section title="Full vs. Partial Modification">
      
        <t>The current state of a resource may be modified in part or in full
        using either the <xref target="RFC5789">PATCH</xref> or PUT HTTP 
        methods, respectively.</t>
      
        <t>Given a URI that represents an resource, the current state of that
        resource can be modified in full by sending an HTTP PUT request to 
        the URI. The payload of the PUT request is considered to be a replacement
        for the identified resource, although the server is free to determine 
        exactly how the resource is to be modified.</t>
      
        <figure><preamble>For example, suppose an application wishes to modify 
        an existing profile that contains nothing more than a name and en email 
        address. First, the application needs to GET the existing state of the 
        profile so it can know what it is working with and can get the Entity 
        Tag necessary for the PUT operation:</preamble><artwork>
  GET /api/people/@me/@self HTTP/1.1
        </artwork></figure>

        <figure><preamble>The server responds with the profile:</preamble><artwork>
  HTTP/1.1 200 OK
  Content-Type: application/json
  ETag: "ab12cd34ef56"

  {"name":{"displayName":"J. Doe"}, 
   "emails":[{"value":"john.doe@example.org"}]}
        </artwork></figure>
      
        <figure><preamble>The application wishes to modify this profile such that
        the name is expanded from "J. Doe" to "John Doe" and the email address 
        is dropped completely. The application can do so by sending the following 
        PUT request:</preamble><artwork>
  PUT /api/people/@me/@self HTTP/1.1
  If-Match: "ab12cd34ef56"
  Content-Type: application/json

  {"name":{"displayName":"John Doe"}}
        </artwork></figure>

        <figure><preamble>Assuming the change is successful, the server would
        respond with an appropriate 2xx status, and MAY include the updated 
        representation of the resource:</preamble><artwork>
  HTTP/1.1 200 OK
  Content-Type: application/json
  ETag: "ab12cd34ef57"

  {"name":{"displayName":"John Doe"}}
        </artwork></figure>

        <figure><preamble>Alternatively, the application can use a PATCH 
        request to perform a partial modification of the resource. For instance, 
        suppose the application needs to add an email address to the previously 
        modified profile:</preamble><artwork>
  PATCH /api/people/@me/@self HTTP/1.1
  If-Match: "ab12cd34ef57"
  Content-Type: application/json-patch

  [{"add":"/emails","value":{"value":"j.doe@example.com"}}]
        </artwork></figure>
      
        <figure><preamble>Assuming the change is successful, the server would
        respond with an appropriate 2xx status, and MAY include the updated
        representation of the resource:</preamble><artwork>
  HTTP/1.1 200 OK
  Content-Type: application/json
  ETag: "ab12cd34ef57"
  
  {"name":{"displayName":"John Doe"},
   "emails":[{"value":"j.doe@example.com"}]
  }
        </artwork></figure>
      
        <t>Support for the PATCH method to perform partial modifications of
        resource is optional.</t>
      
        <section title="PATCH Document Formats">
      
          <t>OpenSocial REST Services that implement support for the PATCH
          operation MUST, at a minimum, support the use of the 
          <xref target="I-D.draft-ietf-appsawg-json-patch">JSON Patch 
          document format</xref> for describing partial modifications and 
          MAY support the use of the JSON Merge Patch mechanism as defined by 
          section 3 of <xref target="I-D.draft-snell-merge-patch"/>.</t>
          
          <t>With JSON Patch, the payload of the HTTP PATCH request uses a 
          simple JSON data structure to explicitly describe the changes 
          being requested to the data.</t>
          
          <figure><preamble>For example, when working with an OpenSocial
          Person object, to change the value of a person's given name and 
          add a new phone number, the request would be:</preamble>
          <artwork>
  PATCH /people/@me/@self HTTP/1.1
  Content-Type: application/json-patch
  
  [{"replace":"/name/givenName","value":"John"},
   {"add":"/phoneNumbers","value":{"label":"home","value":"123-123-1234"}]
          </artwork></figure>
          
          <t>The advantage of using the JSON Patch format is that the 
          requested changes are unamgibuous and clear, regardless of 
          specific details of the implementation.</t> 
          
          <t>If the JSON Patch document specifies any change that cannot be
          made, i.e. it references a field that does not exist, or attempts 
          to make a change that would cause the resulting data to be invalid 
          in any way, the server MUST reject the PATCH request without making
          any changes to the target resource.</t>
          
          <t>As an alternative, the <xref target="I-D.draft-snell-merge-patch">
          Merge Patch</xref> mechanism allows a client to requests partial 
          modifications to be made by example. </t>
          
          <figure><preamble>For example, given the following data object:</preamble>
          <artwork>
  {
    "displayName": "John Doe",
    "name" : {
      "givenName" : "John",
      "familyName" : "Doe"
    },
    "tags":["example","sample"]
  }
          </artwork></figure>
          
          <t>If the intent is to change the value of the "displayName" property 
          from "John Doe" to the value "J. Doe", add a new "phoneNumber" property,
          remove the "familyName" property from the "name" object, and remove
          the word sample from the "tags" Array, I would send the following
          request:</t>

          <figure><artwork>
  PATCH /my/resource HTTP/1.1
  Host: example.org
  Content-Type: application/json+merge-patch; charset="UTF-8"

  {
    "displayName": "J. Doe",
    "phoneNumber": "+01-123-456-7890",
    "name": {
      "familyName": null
    }
    "tags": ["example"]
  }
          </artwork></figure>
        
          <t>Servers that support the Merge Patch mechanism MUST adhere to the 
          rules specified in Section 3 of <xref target="I-D.draft-snell-merge-patch"/>
          to determine the specific set of changes that is being requested.</t>
          
          <t>As with JSON Patch, if the Merge Patch request specifies any 
          change that cannot be made for any reason, the server MUST reject
          the PATCH request without making any changes to the target resource.</t>
        
          <t>REST Services that support PATCH MUST advertise that support using 
          the Accept-Patch HTTP Response header as defined by 
          <xref target="RFC5789"/>, Section 3.1</t>
        
          <figure><preamble>For example,</preamble><artwork>
  HTTP/1.1 200 OK
  Allow: GET, PUT, POST, DELETE, HEAD, PATCH, OPTIONS
  Accept-Patch: application/json-patch, application/json+merge-patch
          </artwork></figure>
        </section>

      </section>
      <!--  END PARTIAL MODIFICATION -->
      
      <section title="Error Handling" anchor="reporting-errors">
      
        <t>When errors occur during the processing of a request sent to a 
        REST service, the HTTP response will specify an appropriate error
        status identifying the general nature of the failure that occurred
        as well as any relevant specific detail.</t>
        
        <t>Errors in processing generally fall in to one of the following
        three categories:
          <list style="hanging">
            <t hangText="Functional Errors">
              Typically occur when unforseen and unexpected error conditions 
              arise on the server. For instance, when there is no additional
              storage space available; when when a required service is 
              unavailable. 
            </t>
            <t hangText="Request Validation Errors">
              Typically occur when a request sent to a service is malformed 
              in any way and cannot be processed; or when the request has not 
              been properly authenticated.
            </t>
            <t hangText="Business Rule Violations">
              Typically occur when a request cannot be completed because doing
              so would violate some underlying business rule. For instance, 
              if a validly formed and properly authenticated request to change
              a property values on a particular resource to an invalid value
              type.
            </t>
          </list>
        </t>
        
        <t>When a Functional Error occurs during the processing of a request,
        server implementations MUST take cautions against inappropriately 
        disclosing too much detail about the underlying implementation of the 
        service. Unless the user-agent submitting the request is considered to
        be a trusted entity by the server, error responses that represent 
        Functional Errors SHOULD contain only a minimal amount of information 
        about the error.</t>
        
        <t>Function Errors are typically reported using 5xx Server Error 
        response codes as defined in Section 7.5 of 
        <xref target="I-D.draft-ietf-httpbis-p2-semantics"/>.</t>
        
        <figure><preamble>The example response below communicates that the 
        service is unavailable to process any requests and that the user agent
        can retry the request in two minutes:</preamble><artwork>
  HTTP/1.1 503 Service Unavailable
  Retry-After: 120
        </artwork></figure>
        
        <t>When a Request Validation Error occurs, the server MUST provide 
        adequate detail in the response to indicate the nature of the validation 
        failure. Such errors can occur for a variety of reasons and are generally
        reported using 4xx Client Error response codes as defined in Section 7.4
        of <xref target="I-D.draft-ietf-httpbis-p2-semantics"/>. If a payload is
        included in the HTTP Response, then it SHOULD be a JSON document 
        containing a single <xref target="error-object">Error Object</xref>
        that describes the specific validation error that occurred. A payload
        will not be required for all Request Validation Errors. The choice of 
        whether to include a payload describing the error for any particular 
        request is left up to the server.</t>
       
        <figure><preamble>The example response below indicates that the request
        was not properly authenticated and indicates that the user-agent must
        use OAuth 2.0 Bearer tokens to authenticate future requests.</preamble><artwork>
  HTTP/1.1 403 Forbidden
  WWW-Authentication: Bearer realm="example"
        </artwork></figure>
        
        <t>When Business Rule Violations occur, the server MUST provide
        adequate detail in the response to indicate the nature of the violation.
        Such errors can occur for a variety of reasons are are generally reported
        using specific HTTP response codes such as 409 Conflict, 403 Forbidden,
        or 400 Bad Request. Such responses MUST contain a payload consisting
        of a single <xref target="error-object"/> that describes the specific
        violation.</t>
        
        <t>Business Rule Violations differ from other types of errors in that,
        typically, the request is properly formed and understood by the service, 
        but was rejected for some other reason. An example of such an error 
        is when a particular user agent surpasses a preallocated number of 
        requests within a given period of time.</t>
        
        <figure><preamble>For example:</preamble><artwork>
  HTTP/1.1 403 Forbidden
  Content-Type: application/json
  
  {
    "code": -12345,
    "message": "Exceeded request quota"
  }
        </artwork></figure>
        
        <section title="The Error Object" anchor="error-object">
        
          <t>The Error object is a simple JSON data structure intended to 
          communicate basic information about an error condition that 
          has occurred.</t>
          
          <t>Error objects conform to all the same rules as all other 
          OpenSocial <xref target="data-objects">Data Objects</xref>, 
          including extensibility characteristics. At a minimum, Error objects 
          have the following properties:</t>
          
          <texttable>
            <ttcol>Name</ttcol>
            <ttcol>Type</ttcol>
            <ttcol>Description</ttcol>
            
            <c>code</c>
            <c>Integer</c>
            <c>A numeric code indicating the specific nature of the error 
            that occurred. When an error object is included as the payload
            of an HTTP response, this code MUST NOT be interpreted as a 
            replacement for the HTTP response status code, which takes 
            precedence and specifies the general status of the HTTP 
            request. No standard error code values are defined by this
            specification.</c>
            
            <c>data</c>
            <c>Object</c>
            <c>A JSON object containing arbitrary additional data about the 
            error. The specific properties of the object are undefined.</c>
            
            <c>message</c>
            <c>String</c>
            <c>A human readable and localized description of the error that 
            occurred. The value SHOULD NOT contain markup of any kind and 
            SHOULD be interpreted as plain text.</c>
            
          </texttable>
          
          <t>When an error object is included as the payload of an HTTP
          message, the Content-Type header field, if specified, MUST specify 
          a value of "application/json".</t>
        
        </section>
        <!--  END ERROR OBJECT -->
      
      </section>
      <!--  END ERROR HANDLING -->
      
      <section title="Multiple resource and aspect operations" anchor="multiple-resources">
      
        <t>For the GET, HEAD and OPTIONS HTTP methods, a REST service MAY
        support the ability for a user-agent to specify multiple 
        local-identifiers and aspect-identifiers within a single request URI. 
        There are, however, a number of important caveats and considerations 
        that need to be taken into consideration when working with multiple 
        resources and multiple aspects within a single operation.</t>
        
        <t>To illustrate how the support for multiple resources works, 
        consider a profile service that provides access to information about
        different users. A user-agent can access the profiles of individual 
        users by issuing a GET request to their respective URIs:</t>
        
        <figure><artwork>
  GET /api/people/user-1/@self HTTP/1.1
  GET /api/people/user-2/@self HTTP/1.1
  GET /api/people/user-3/@self HTTP/1.1
        </artwork></figure>
      
        <t>Each of these requests would return a single profile representations:</t>
        
        <figure><artwork>
  HTTP/1.1 200 OK
  Content-Type: application/json
  ETag: "abcdef123456"
  
  {
    "id": "acct:user-1@example.org",
    "name": {"displayName": "John Doe"}
  }
        </artwork></figure>
      
        <t>Using the multiple-resource capability, these three distinct 
        HTTP requests can be combined into a single request:</t>
        
        <figure><artwork>
  GET /api/people/user-1,user-2,user-3/@self HTTP/1.1
        </artwork></figure>
        
        <t>This combined request would return each of the requested profiles
        within a single response consisting of a single top-level JSON object
        containing one property for each requested object, where the property
        key is the local-identifier of the resource:</t>
        
        <figure><artwork>
  HTTP/1.1 200 Ok
  Content-Type: application/json
  ETag: "abcdefg123456"
  
  {
    "user-1": {
      "id": "acct:user-1@example.org",
      "name": {"displayName": "John Doe"}
    },
    "user-2": {
      "id": "acct:user-2@example.org",
      "name": {"displayName": "Jane Doe"}
    },
    "user-3": {
      "id": "acct:user-3@example.org",
      "name": {"displayName": "Sally Jones"}
    }
  }
        </artwork></figure>
        
        <t>If one of the requested resources does not exist, the server MAY
        choose to either reject the entire request with a 404 Not Found response
        or simply omit the missing item from the response or optionally include
        an explicit indicator that the specific item could not be found.</t>
        
        <figure><preamble>For instance, if "user-3" does not exist, the following:</preamble>
        <artwork>
  HTTP/1.1 200 Ok
  Content-Type: application/json
  ETag: "abcdefg123456"
  
  {
    "user-1": {
      "id": "acct:user-1@example.org",
      "name": {"displayName": "John Doe"}
    },
    "user-2": {
      "id": "acct:user-2@example.org",
      "name": {"displayName": "Jane Doe"}
    },
    "user-3": null
  }
        </artwork></figure>
        
        <figure><preamble>Is equivalent to omitting the "user-3" property
        altogether:</preamble>
        <artwork>
  HTTP/1.1 200 Ok
  Content-Type: application/json
  ETag: "abcdefg123456"
  
  {
    "user-1": {
      "id": "acct:user-1@example.org",
      "name": {"displayName": "John Doe"}
    },
    "user-2": {
      "id": "acct:user-2@example.org",
      "name": {"displayName": "Jane Doe"}
    }
  }
        </artwork></figure>
        
        <t>When the request specifies multiple aspect identifiers, the JSON 
        object contained within the response will contain an additional layer
        of property values representing each individual aspect.</t>
        
        <t>For instance, if the user-agent wishes to retrieve both the profile
        and friends list for the current authenticated user, it could send a 
        GET request to:</t>
        
        <figure><artwork>
  GET /api/people/@me/@self,@friends
        </artwork></figure>
        
        <t>The response to this request would include a single top-level JSON
        object with properties for each of the requested aspects, whose values
        will be equivalent to what would have been returned had each aspect
        been requested by individual requests:</t>
        
        <figure><artwork>
  HTTP/1.1 200 OK
  Content-Type: application/json
  ETag: "abcdefg1234567"
  
  {
    "@self": {
      "id": "acct:user-1@example.org",
      "name": {"displayName": "John Doe"}
    }, 
    "@friends": {
      "items": [
        {
          "id": "acct:user-2@example.org",
          "name": {"displayName": "Jane Doe"}
        },
        {
          "id": "acct:user-3@example.org",
          "name": {"displayName": "Sally Jones"}
        }
      ]
    }
  }
        </artwork></figure>
        
        <t>When multiple local-identifiers and aspect-identifiers are specified,
        the construction of the returned JSON object is similarly nested:</t>
        
        <figure><artwork>
  GET /api/people/user-1,user-2/@self,@friends
        </artwork></figure>
        
        <figure><artwork>
  HTTP/1.1 200 OK
  Content-Type: application/json
  ETag: "abcdefg1234567"
  
  {
    "user-1": {
      "@self": {
        "id": "acct:user-1@example.org",
        "name": {"displayName": "John Doe"}
      }, 
      "@friends": {
        "items": [
          {
            "id": "acct:user-2@example.org",
            "name": {"displayName": "Jane Doe"}
          },
          {
            "id": "acct:user-3@example.org",
            "name": {"displayName": "Sally Jones"}
          }
        ]
      }
    },
  "user-2": {
      "@self": {
        "id": "acct:user-2@example.org",
        "name": {"displayName": "Jane Doe"}
      }, 
      "@friends": {
        "items": [
          {
            "id": "acct:user-1@example.org",
            "name": {"displayName": "John Doe"}
          }
        ]
      }
    }
  }
        </artwork></figure>
        
        <t>If the data that would normally be returned when requesting a 
        particular local-identifier and aspect-identifier cannot be represented
        as JSON -- for instance, when requesting a hypothetical 
        <spanx style="verb">@avatar</spanx> aspect for a particular profile 
        that could return a binary image resource-- the value for the given 
        item within the JSON response MUST specify the IRI of the specific 
        individual item within a field named "$self".</t>
        
        <figure><preamble>For instance:</preamble><artwork>
  GET /people/api/@me/@self,@avatar HTTP/1.1
  Host: example.org
        </artwork></figure>
        
                <figure><artwork>
  HTTP/1.1 200 OK
  Content-Type: application/json
  ETag: "abcdefg1234567"
  
  {
    "@self": {
      "id": "acct:user-1@example.org",
      "name": {"displayName": "John Doe"}
    }, 
    "@avatar": {
      "$self": "http://example.org/people/api/@me/@avatar"
    }
  }
        </artwork></figure>
        
        <t>Filter segment and query string parameters included in the request 
        URI apply to each of the individually requested resources just as if 
        separate requests were sent to each resource.</t>
        
        <figure><preamble>For instance, the request:</preamble><artwork>
  GET /api/activity/user-1,user-2/@all/app-1,app-2/@tags/foo,bar?fields=id,title
        </artwork></figure>
        
        <t>Is to be interpreted as: for users "user-1" and "user-2", return the 
        id and title fields for all activities generated by applications "app-1"
        and "app-2" and tagged with "foo" or "bar".</t>
        
        <t>Authentication credentials included in the request MUST be valid
        and authorized for each of the individually requested resources or the
        entire request MUST be rejected using either a 401 Unauthorized or 
        403 Forbidden response.</t>
        
        <t>Modification of multiple resources with a single operation, as well
        as the use of any unsafe and non-idempotent HTTP method is not allowed.
        Any method other than GET, HEAD and OPTIONS sent to a request URI 
        specifying multiple resources MUST fail with a response of 405 Method 
        Not Supported</t>

        <t>When a request contains either a If-Modified-Since or If-Unmodified-Since
        request header, the server MUST determine if all of the requested
        resources or aspects adhere to the condition. If even just
        one of the requested resources fails to meet the condition, the entire
        request MUST be rejected using a 406 Not Acceptable response.</t>
      
        <t>Implementations SHOULD place strict limits on the number of distinct 
        resources and aspects that may be included within a single request URI. 
        When a user agent submits a request for too many resources or aspects,
        the server SHOULD return a 414 Request-URI Too Long response.</t>
        
        <t>If an implementation does not support the specification of multiple
        resources or aspects within a single request, a 404 Not Found response 
        SHOULD be returned.</t>
        
      </section>
      <!-- END BATCH GET -->
      
      <section title="Operation Identifiers" anchor="operation-identifiers">
    
        <t>For the purpose of simplifying an interaction with various REST 
        services, an OpenSocial implementation that provides Application 
        Container Services (see <xref target="core-gadget"/>) can provide a 
        layer of code that abstracts the REST service request and provides a 
        simplified interface.</t>
        
        <t>In order to better facilitate interoperability within that abstraction
        layer, OpenSocial REST Services can specify a alias for each logical 
        interaction the application can have with the service. Such aliases 
        take the form:</t>
        
        <figure><artwork>
  operation-identifier = service-identifier "." token
        </artwork></figure>
        
        <t>For example, the OpenSocial Person Service provides operations that
        allow a user-agent to request information about specific people. When
        interacting directly with the REST Service, this request takes the 
        form of an HTTP GET request:</t>
        
        <figure><artwork>
  GET /api/people/@me/@self HTTP/1.1
  Host: example.org
        </artwork></figure>
    
        <t>Within an OpenSocial Application hosted within an OpenSocial 
        container (see <xref target="core-gadget"/>), this same operation
        can be referenced using the operation identifier "people.get":</t>
        
        <figure><artwork><![CDATA[
  <Module>
    <ModulePrefs>
      ...
    </ModulePrefs>
    <Data>
      <os:DataRequest key="me" method="people.get" userId="@me" groupId="@self" />
    </Data>
    <Content type="html">
      ...
    </Content>
  </Module>
        ]]></artwork></figure>
    
        <t>Operation identifiers specific to each of the core OpenSocial REST 
        Services are defined within the OpenSocial Social Applications 
        Specifications <xref target="social-app"/>.</t>
    
      </section>
      
    </section>
    <!-- END REST SERVICES -->
    
    <section title="Dates, Times and Timezone Offsets" anchor="datetimes">
      
      <t>Whenever date, time, timezone, duration or time period data is 
      used anywhere within an OpenSocial implementation, the following 
      rules MUST be applied.</t>
    
      <t>When encoding a Date and Time together, the date-time construct 
      from <xref target="RFC3339"/> MUST be used. In addition, an uppercase 
      "T" character MUST be used to separate the date and time, and an 
      uppercase "Z" character MUST be present in the absence of a numeric 
      time zone offset.</t>
      
      <figure><preamble>For example:</preamble><artwork>
  2012-11-09T12:32:34-08:00
  2013-03-23T01:23:43Z
      </artwork></figure>
      
      <t>When encoding a Date, the full-date construct from <xref target="RFC3339"/> 
      MUST be used.</t>
      
      <figure><preamble>For example:</preamble><artwork>
  2012-11-09
      </artwork></figure>
      
      <t>When encoding a Time, either the partial-time or full-time
      constructs from <xref target="RFC3339"/> MUST be used. When encoded as 
      a full-time, an uppercase "Z" character MUST be present in the absence 
      of a numeric time zone offset.</t>
      
      <figure><preamble>For example:</preamble><artwork>
  12:32:34-08:00 // full-time
  12:32:34       // partial-time
      </artwork></figure>
      
      <t>When encoding a Timezone Offset, the time-offset construction 
      from <xref target="RFC3339"/> MUST be used. Note that when denoting a 
      Timezone Offset equal to the Coordinated Universal Time (UTC), an 
      uppercase "Z" character MUST be used.</t>
      
      <figure><preamble>For example:</preamble><artwork>
  -08:00
      </artwork></figure>
      
      <t>When encoding a Duration, the duration construction from <xref target="RFC3339"/>
      MUST be used.</t>
      
      <figure><preamble>For example:</preamble><artwork>
  P3Y6M4DT12H30M5S
      </artwork></figure>
    
      <t>When encoding a period of time, the period constructions from 
      <xref target="RFC3339"/> MUST be used. Note that when the period 
      contains explicit date and time components, an uppercase "T" character
      MUST be used to separate the date and time, and an uppercase "Z"
      character MUST be used in the absence of a numeric time zone offset.</t>
      
      <figure><preamble>For example:</preamble><artwork>
  P1Y2M10DT2H30M/2008-05-11T15:30:00Z
      </artwork></figure>
    
    </section>
 
    <section title="Data Objects" anchor="data-objects">
      
      <t>All Data Objects exposed via REST Services are serialized as 
      JSON Objects as defined by <xref target="RFC4627"/>. Alternative 
      serializations MAY be used but are considered outside the scope of
      this specification. Previous versions of OpenSocial allowed for 
      <xref target="RFC4287">Atom</xref> and simple XML serializations 
      that have now been deprecated. Each of these are documented in the 
      OpenSocial Deprecated Support Specification [TODO: Ref Doc].
      Implementations MAY support the deprecated formats for backwards 
      compatibility with existing applications.</t>   
        
      <t>Unless otherwise stated in the definition of a specific property, 
      the following general serialization rules apply:
        <list style="symbols">
          <t>Absent properties MAY be represented either by an explicit 
          declaration of the property whose value is null or by omitting the 
          property declaration altogether at the option of the publisher; 
          these two representations are semantically equivalent. If a property 
          is having a value whose type is a JSON array, the absence of any 
          items in that array SHOULD be represented by omitting the property 
          entirely or publishing it with the value null, and SHOULD NOT 
          be represented as an empty array.</t>
          <t>Member values of an array value SHOULD be uniform in type. That is, 
          Array values SHOULD NOT contain a mix of primitive, array and object
          data types, for instance <spanx style="verb">"foo":["a","b","c"]</spanx>
          is acceptable while <spanx style="verb">"bar":["a",{"b":"c"},["d","e"]]</spanx>
          is not.</t>
          <t>When a property is defined as a boolean and the value is false, 
          the property MAY be omitted entirely from the JSON serialization.</t>
          <t>When a property is defined as a "plural field", it's value MUST be 
          serialized as an Array of Plural Objects as defined by <xref target="plural-objects"/>.</t>        
          <t>All <xref target="RFC3987">IRI</xref> and <xref target="RFC3986">URI</xref>
          references contained with the serialized JSON structure SHOULD be 
          absolute. If relative URI and IRI references are used, and the serialized
          JSON is included within either an HTTP request or returned in response 
          to an HTTP request, the references are to be resolved relative to either 
          the HTTP Request URI or the value of the Content-Location response 
          header, if one is included within the HTTP response.</t>
          <t>All dates, times, durations and periods of time are to be encoded as 
          specified in <xref target="datetimes"/>.</t>
          <t>When a Data Object is defined as a "collection", it's value MUST
          be serialized as defined in <xref target="collection-objects"/>.</t>
        </list>
      </t>
        
      <section title="Collection Objects" anchor="collection-objects">
        
        <t>A "Collection Object" is a Data Object that represents a set of 
        individual, related Data Objects. Collection Objects are serialized
        as JSON Objects conforming to the JSON Activity Streams Collection
        construct as defined in Section 3.5 of <xref target="json-activity-streams"/>.</t>
          
        <t>Such serialized objects inherit all of the basic properties of 
        the Activity Streams Collection object:
          <texttable>
            <ttcol>Name</ttcol>
            <ttcol>Type</ttcol>
            <ttcol>Description</ttcol>
            <c>totalItems</c>
            <c>JSON Integer</c>
            <c>An optional, non-negative integer specifying the total number
            of items within the collection. This number SHOULD reflect the 
            actual total number of Data Objects that are considered to be 
            members of the set that can be returned after applying any 
            requested filtering operations and not the number of items actually 
            serialized as values in the <spanx style="verb">items</spanx>
            property value.</c>
            <c>items</c>
            <c>JSON Array</c>
            <c>An array containing a listing of Data Objects. This listing
            MAY be a subset of the total number of objects considered to be
            members of the collection.</c>
            <c>url</c>
            <c>JSON String</c>
            <c>An optional IRI referencing a JSON Activity Streams document 
            containing the full listing of objects within the collection.</c>
          </texttable>
        </t>
          
        <t>All other properties defined by the JSON Activity Streams 
        specification for a Collection Object MAY be included in the 
        serialization but their specific use and function is considered
        out of scope of this specification.</t>
          
        <t>This specification defines the following additional properties 
        that MAY be used:
          <texttable>
            <ttcol>Name</ttcol>
            <ttcol>Type</ttcol>
            <ttcol>Description</ttcol>
            
            <c>startIndex</c>
            <c>JSON Integer</c>
            <c>A non-negative integer value that identifies the relative 
            position within the collection of the first object contained in 
            the items property. For instance, if there are 20 items that 
            are considered to be members of a collection, but only the last
            10 of those items are serialized within the value of the 
            <spanx style="verb">items</spanx> property, the value of 
            <spanx style="verb">startIndex</spanx> would be 10.</c>
            
            <c>itemsPerPage</c>
            <c>JSON Integer</c>
            <c>A non-negative integer that specifies the maximum number of 
            Data Objects that will be serialized within the value of the 
            <spanx style="verb">items</spanx> property. The actual number 
            of items within the <spanx style="verb">items</spanx> array 
            SHOULD be equal to or less than the value of the 
            <spanx style="verb">itemsPerPage</spanx> value.</c>
            
            <!-- Move to deprecated I hope
            <c>filtered</c>
            <c>JSON Boolean</c>
            <c>TODO: Need to define this better or remove it</c>
            
            <c>sorted</c>
            <c>JSON Boolean</c>
            <c>TODO: Need to define this better or remove it</c>
            
            <c>updatedSince</c>
            <c>JSON Boolean</c>
            <c>TODO: Need to define this better or remove it</c>
            -->
            
          </texttable>
        </t>
          
        <figure><preamble>The following example shows a subset of a 
        collection of OpenSocial Person objects:</preamble><artwork>
  {
    "totalItems": 10,
    "startIndex": 0,
    "itemsPerPage" : 2,
    "items" : [
      {
       "displayName":"Joe",
       "name": {
         "givenName":"Joe",
         "familyName":"Smith"
       }
      },
      {
       "displayName":"Sally",
       "name": {
         "givenName":"Sally",
         "familyName":"Jones"
       }
      }
    ]
  }
        </artwork></figure>
        
        <section title="Multi-page Collections">
        
          <t>Collections that consist of a large number of items can often 
          be split into multiple documents, or pages, where each page contains
          a subset of the total number of items in the complete set as well as 
          links to subsequent or preceding pages.</t>
          
          <t>Within a Collection object, links to pages are represented using
          the generalized Activity Streams Links mechanism described in
          <xref target="astream-links"/>. Specifically, the following table
          lists the additional optional Collection Object properties used to
          link multiple pages of a collection:</t>
          
          <texttable>
            <ttcol>Name</ttcol>
            <ttcol>Type</ttcol>
            <ttcol>Description</ttcol>
            
            <c>$first</c>
            <c>String</c>
            <c>A String value containing the absolute IRI reference of the 
            furthest preceding page of the multi-page collection.</c>
            
            <c>$last</c>
            <c>String</c>
            <c>A String value containing the absolute IRI reference of the
            furthest following page of the multi-page collection.</c>
            
            <c>$previous</c>
            <c>String</c>
            <c>A String value containing the absolute IRI reference of the 
            immediately preceding page of the multi-page collection.</c>
            
            <c>$next</c>
            <c>String</c>
            <c>A String value containing the absolute IRI reference of the 
            immediately following page of the multi-page collection.</c>
            
            <c>$current</c>
            <c>String</c>
            <c>A string value containing the absolute IRI reference of a 
            page containing the items that have been updated most recently.</c> 
            
          </texttable>
          
          <t>In order to be considered a paged collection, at least one 
          of these properties MUST be present within the Collection object.</t>
          
          <figure><preamble>For example,</preamble><artwork><![CDATA[
  {
    "$first": "http://example.org/activities/@me/@all?count=10",
    "$next": "http://example.org/activities/@me/@all?count=10&updatedBefore=2012-12-12T12:12:12.123Z",
    "totalItems": 100,
    "items": [
      // .. list of items
    ]
  }
          ]]></artwork></figure>
          
          <t>Note that consuming applications SHOULD treat the absolute IRI
          values used for paging as opaque identifiers and MUST NOT assume 
          that they conform to any particular structure. That said, it is expected
          that most implementations will use various combinations of the 
          standard query string parameters (e.g. count and startIndex, or 
          count and updatedBefore) to construct paging links.</t>
          
          <t>When using a combination of the count and startIndex query 
          parameters to facilitate paging of a collection whose items 
          change or grow frequently over time, the process of splitting 
          a collection into multiple pages can become "lossy". That is, 
          it is not possible to guarantee that consuming applications
          will be able to reconstruct the complete contents of the full
          collection at a particular time because items can be added or 
          changed as the pages are accessed without the consuming application
          becoming aware of them.</t>
          
          <t>Such data loss can be avoided through the use of the updatedSince
          and updatedBefore parameters as an alternative to startIndex. That 
          is, rather than basing pages on the relative positioning of items 
          within the overall collection, pages can be constructed to represent
          distinct periods of time (e.g. the 30 entries updated before a given 
          time; all entries updated within the last hour; etc).</t>
        
        </section>
        
      </section>
        
      <section title="Plural Objects" anchor="plural-objects">
        
        <t>Within an OpenSocial Data Object, a "plural-field" is a property
        whose value consists of zero or more alternative choices represented as
        individual elements within a JavaScript Array. Each choice is serialized 
        as a JSON Object with at least the following basic 
        properties:
          <texttable>
            <ttcol>Name</ttcol>
            <ttcol>Type</ttcol>
            <ttcol>Description</ttcol>
            
            <c>label</c>
            <c>JSON String</c>
            <c>Provides a human-readable, plain-text, and preferrably 
            localized short description of the object value suitable 
            for display to a user.</c>
            
            <c>primary</c>
            <c>JSON Boolean</c>
            <c>A boolean value indicating whether a particular plural object
            value is considered to be the primary or preferred alternative
            within the set. No more than one object in the array of of objects
            specified as the value of a plural field can have a 
            <spanx style="verb">primary</spanx> property of True.</c>
            
            <c>type</c>
            <c>JSON String</c>
            <c>Specifies a machine-processable label for this object value
            that generally identifies it's preferred function. For 
            instance, if the plural field represents a collection of phone
            numbers, the <spanx style="verb">type</spanx> property value 
            would specify values such as "work", "home" or "other", to
            differentiate each phone number by purpose. Unlike the 
            <spanx style="verb">label</spanx> property which is intended 
            for human-readable display, the <spanx style="verb">type</spanx>
            property is intended to be used programmatically and MUST NOT
            utilize a localized value.</c>
            
            <c>value</c>
            <c>JSON Primitive, Array or Object</c>
            <c>Represents the actual value of the object.</c>
            
          </texttable>
        </t>
          
        <figure><preamble>The example below shows a Data Object with a single
        plural-field providing alternative contact phone numbers for an 
        individual. Each is labeled, typed and a single number is marked 
        as preferred:</preamble><artwork>
  {
    "phoneNumbers": [
      {
        "value": "555-123-1234",
        "type": "home",
        "label": "Home"
      },
      {
        "value": "555-123-1235",
        "type": "work",
        "label": "Work",
        "primary": true
      },
      {
        "value": "555-123-1236",
        "type": "mobile",
        "label": "Mobile"
      }
    ]
  }
        </artwork></figure>
        
      </section>
        
      <section title="Data Object Extensions" anchor="extension-objects">
        
        <t>This specification defines a core set of common Data 
        Objects and an associated set of properties for each. These properties
        comprise the core vocabulary of the OpenSocial Data Model. Implementations
        are free to introduce extensions to this vocabulary so long as such
        extensions do not alter the semantics or requirements associated with
        any part of the core vocabulary. Such extensions are referred to
        generically as "foreign properties".</t>
        
        <t>Note that future versions of this specification could introduce 
        new properties and Data Objects to the core vocabulary. Software 
        written to conform to this version of the specification will not be
        able to process such properties correctly and, in fact, will not be able
        to distinguish it from other arbitrary types of extensions. For the
        purpose of this discussion, unrecognized core vocabulary properties 
        introduced by future versions of this specification will be 
        considered to be "foreign properties".</t>
        
        <t>Implementations that encounter foreign properties within a
        Data Object MUST NOT stop processing or signal an error. It might
        be the case that the implementation is able to process foreign
        properties correctly and does so. Otherwise such properties are
        considered to be "unknown foreign properties".</t>

        <t>Whenever unknown foreign properties are encountered, implementations
        SHOULD ignore the properties and continue processing the Data Object
        as if they were not present.</t>
        
        <t>The values of extension properties SHOULD be serialized following
        the same rules specified for core vocabulary properties as defined 
        in <xref target="data-objects" />.</t>
          
        <section title="Avoiding Naming Conflicts">
        
          <t>Because foreign properties can be added at any time to a Data
          Object by multiple implementations, and because there is no centralized
          coordination of such extensions, there is a risk of conflicts arising
          when multiple implementations attempt to define foreign properties 
          that share the same name.</t>
          
          <t>For example, imagine two separate vendor implementations that 
          extend the basic OpenSocial Person Data Object to include data 
          specific to each implementation. For the sake of illustration, we 
          will label these implementations as "foo.example.org" and 
          "bar.example.com". Each defines a foreign property named 
          "account" that while similar in purpose specify different types 
          of values.</t>
          
          <t>In order to avoid conflicts between the two properties, each 
          implementation SHOULD wrap each of their respective foreign 
          properties into a single root extension property whose name is 
          unique to the implementation and whose value is a JSON Object containing
          the set of foreign properties unique to that implementation.</t>
          
          <t>By convention, it is RECOMMENDED that the name of the root 
          extension property follow the so-called "reverse-DNS" naming 
          pattern.</t>
          
          <figure><preamble>For example, the extended Person Data Object 
          described above could be serialized as:</preamble><artwork>
  {
    "displayName": "Joe",
    "org.example.foo": {
      "account": "joes-account"
    },
    "com.example.bar": {
      "account": {
        "id": "acct:joe@bar.example.com"
      }
    }
  }
          </artwork></figure>
            
          <t>The JSON objects associated with each root extension property
          can contain any number of foreign properties, depending on the 
          needs of the implementation, allowing all of the foreign 
          properties specific to a particular implementation or serving 
          a common purpose to be grouped together.</t>
          
          <t>By following this convention, implementations can protect 
          themselves from conflicts with each other and with new properties
          that may be added by future versions of this specification.</t>
          
        </section>
      
      </section>
      
      <section title="Data Object Type Identifiers" anchor="data.type.identifiers">
      
        <t>Every OpenSocial Data Object has an associated data type identifier
        in the form of an absolute IRI reference that is used in a number of 
        different places throughout OpenSocial applications. Such IRIs are 
        used for identification purposes only and MUST be compared on a 
        character-by-character basis in a case-insensitive fashion.</t>
        
        <t>All data type identifiers that begin with the prefix "http://opensocial.org/types/"
        are reserved for use by this specification. Implementations MUST NOT 
        use any data type identifier that begins with the prefix "http://opensocial.org/types/"
        other than those defined by the OpenSocial specification. Please refer 
        to <xref target="social-app"/> for details on the current set of data 
        types defined by OpenSocial.</t>
        
        <section title="Legacy Data Type Identifiers" anchor="legacy.data.type.identifiers">
        
          <t>Older versions of this specification utilized an alternative, 
          now-deprecated syntax for data type identifiers:</t>
          
          <figure><artwork>
  segment = 1*( ALPHA / DIGIT )
  prefix = segment "."
  name = segment
  legacy-datatype = prefix name
          </artwork></figure>
          
          <t>For example, the legacy data type identifier for the OpenSocial
          Person datatype was "opensocial.Person".</t>
          
          <t>For backwards compatibility purposes with existing applications, 
          implementations MAY continue to support the use of Legacy Data Types.
          New applications for which backwards compatibility is not a concern, 
          however, SHOULD NOT use legacy data type identifiers.</t>
        
        </section>
        
      </section>
      
    </section>
    <!--  END DATA OBJECTS -->
   
    <section title="Security" anchor="Security"> 

      <t>When a REST Service provides access to protected resources for which
      authentication is required, the service MUST support the use of either 
      OAuth version 1.0a, OAuth version 2.0 or both as the preferred authentication
      mechanism. Specific implementations MAY support additional alternative 
      autentication mechanisms but support for such is considered out of the 
      scope of this specification.</t>
      
      <t>REST Services MAY accept requests with no authentication or 
      authorization information for data considered to be public. The service 
      MAY provide a limited "public representation" of a resource if no 
      authorization information is provided in the request.</t>
      
      <t>In the case where no information is available due to lack of authorization,
      an HTTP 401 Unauthorized response SHOULD be returned to the client. In the
      case where at least some view of the information is available, it SHOULD be
      returned using an appropriate 2xx status, with a standard WWW-Authenticate
      response header indicating that additional information may be available 
      when using a different authorization context.</t>
      
      <section title="OAuth 1.0a and 2.0 Support">
        
        <t>When utilizing the OAuth protocol, the overall flow is straightforward:</t>
        
        <t>
          <list style="symbols">
          <t>The REST Service provider is the "resource server", providing access
          to one or more protected "resources" for which a "resource owner" MUST
          grant permission to access.</t>
          <t>Any application making use of a REST Service, is an OAuth "client" 
          that MUST first acquire permission from the "resource owner" to access 
          the resources provided by the server.</t>
          <t>Typically, the "resource owner" is the individual that is using the
          application and for which the application is attempting to access the 
          resource.</t>
          <t>Once the client determines that it must access a protected resource, 
          it must first acquire initial authorization. How this is done depends 
          entirely on what version and variation of the OAuth protocol is being 
          used. Generally, this step results in the granting of an "authentication 
          token" to the client.</t>
          <t>Once the client has been authorized, it must ask the authorization 
          server to exchange that authorization token for an access token. This 
          access token, when granted, provides the client with permission -- 
          limited in both time and scope -- to access the protected resource. 
          Because the access token allows the client to operate on behalf of the 
          resource owner, the resource owner has to approve the exchange before 
          the access token can be issued. How the access token is issued depends 
          entirely on what version and variation of the OAuth protocol is being
          used.</t>
          <t>Once the client has been granted an access token, it can use that 
          token within it's requests to access the protected resource for a limited
          period of time. Once the allotted time expires, the client must reacquire
          permission to continued access to the resource by requesting a new 
          access token.</t>
          </list>
        </t>
        
        <t>There are several valid ways in which the initial authorization token
        may be acquired by the client. This specification does not prescribe or 
        require any single acquisition mechanism.</t>
        
        <t>Likewise, there are several valid ways in which an authenticated 
        request can be prepared using the access token once acquired: 
          <list style="symbols">
            <t>When using OAuth 2.0, the access token can be included 
            directly within the request utilizing the so-called "bearer token" 
            mechanism defined by <xref target="I-D.ietf-oauth-v2-bearer"/>
            or the token can be combined with additional data to generate
            a cryptographic hash used for authentication purposes as described by
            <xref target="I-D.ietf-oauth-v2-http-mac"/>.</t>
            <t>When using OAuth 1.0a, the access token is utilized as 
            described in Section 3.0 of <xref target="RFC5849"/>.</t>
          </list>
        </t>
        
        <t>When utilizing OAuth version 2.0, all REST Services MUST, at a minimum, 
        support the use of OAuth 2.0 Bearer Tokens as specified in
        <xref target="I-D.ietf-oauth-v2-bearer"/>. Because such tokens are passed 
        to the server as unencrypted, plain text, all requests containing an 
        OAuth 2.0 Bearer Token MUST be exchanged using TLS 2.0 or SSL.</t>
  
        <t>All access tokens SHOULD be issued with limited scope and short 
        expiration times to limit the risk of potential security breaches due 
        to stolen access tokens. The "scope" of an "access token" identies the 
        range of resources and the types of operations for which the token can 
        be used. The "expiration time" specifies the length of time for which the 
        access token is considered to be valid. The token expiration policy 
        is left to the specific implementation and may vary depending on the 
        client requesting the token. Expiration times of 1 hour or less, and 
        tokens with limited scope may be used with less trusted clients while 
        expiration times of several hours and tokens with increased scope may 
        be used for more trusted clients.  Implementations SHOULD document 
        (at least for administrators) how to configure token scopes and 
        expiration times if these values are configurable.</t>
      </section>
      
      <section title="Signed Fetch">
      
        <t>All REST Services SHOULD support the use of the so-called "Signed Fetch"
        mechanism.</t> 
        
        <t>Signed Fetch is a simplified mechanism based on a subset of the 
        OAuth 1.0a protocol that allows a container to "sign" requests sent
        to a remote endpoint. Such signatures provide only a reasonable 
        assurance that certain content contained within the request has not been
        modified by a malicious party. Once a receiving endpoint determines that it
        is able to trust the signed request, it can decide to provide 
        limited access to certain protected resources without having to
        walk through the entire typical OAuth protocol.</t>
        
        <t>Signed Fetch is described in detail in <xref target="core-gadget">The
        OpenSocial Core Gadget Specification</xref>.</t>
      
      </section>
    
    </section>
    <!--  END SECURITY -->
 
    <section title="Versioning" anchor="versioning">
    
      <t>The ability for server and client implementions to clearly communicate
      which version of the OpenSocial specification a particular Service API
      and resource supports is critical.</t>
      
      <t>For the purpose of clearly identifying which version of the 
      OpenSocial specification a particular application is implementing, a 
      Web Link header referencing the base URI of the OpenSocial specification
      and using a rel attribute value of <xref target="I-D.wilde-profile-link">"profile"</xref> SHOULD be included within
      the HTTP request and response message.</t>
      
      <figure><preamble>For example, the Link would appear within the request:</preamble><artwork>
  GET /api/people/@me/@self HTTP/1.1
  Host: example.org
  Link: &lt;http://opensocial.org/specs/3.0&gt;; rel="profile"
      </artwork></figure>
      
      <figure><preamble>And within the response:</preamble><artwork>
  HTTP/1.1 200 OK
  Link: &lt;http://opensocial.org/specs/3.0&gt;; rel="profile"
      </artwork></figure>
    
      <t>A server MAY choose to implement additional conventions for identifying
      the current version, such as including a version indicator within the 
      base URI of the Service API (e.g. http://example.org/v3/api/people). 
      Such conventions are considered out of scope.</t>
      
      <section title="Upgrade Indication and Transition">
      
        <t>When a server implementation of an older version of the OpenSocial
        specification upgrades to a newer version, it has the responsibility 
        to provide a clear mechanism for either continuing to support client 
        applications using the old version or help clients migrate to the new.
        Whether a server chooses to continue to support the old and new 
        versions of the OpenSocial specification simultaneously is an 
        implementation and business decision that is out of the scope of this
        specification. Accordingly, each of the options detailed below are 
        informative in nature only.</t>
        
        <t>However, when a server wishes to indicate to a client application 
        that the server has been upgraded and that the old version of the API is 
        no longer available, it can do so using an Upgrade Required response.</t>
        
        <figure><preamble>An "Upgrade Required Response" is an HTTP response 
        that uses the 426 Upgrade Required status along with an "profile" 
        Web Link. For instance:</preamble><artwork>
  HTTP/1.1 426 Upgrade Required
  Upgrade: OpenSocial/3.0
  Connection: upgrade 
  Link: &lt;http://opensocial.org/specs/3.0&gt;; rel="profile"
        </artwork></figure>
        
        <t>When using such responses, the Upgrade header MUST specify an
        Upgrade Token value of "OpenSocial" and an Upgrade Version Token
        consisting of the major and minor version identifier as specified
        in Section 1.2 of <xref target="core-gadget"/>.</t>
        
        <t>Use of the 426 Upgrade Required response implies a complete cutover
        from one version of the specification to another. While such a strategy 
        might be appropriate in some cases, many applications will require a more
        gradual approach in order to avoid breaking existing clients. Alternatively, 
        a server can choose to migrate client applications incrementally, initially
        deploying the new version of the application side-by-side with the old.</t>
        
        <t>For example, if a server currently exposes version 3.0 of the 
        OpenSocial Person Service at the URI "http://example.org/api/people", 
        and it wishes to upgrade clients to a hypothetical version 3.1 in the
        future, without requiring clients to change the URIs used to access
        the service, it can either continue to support the 3.0 clients transparently
        or perform an "in place" upgrade.</t>
        
        <figure><preamble>An example 3.0 client request:</preamble><artwork>
  GET /api/people/@me/@self HTTP/1.1
  Link: &lt;http://opensocial.org/specs/3.0&gt;; rel="profile"
        </artwork></figure>
        
        <figure><preamble>A server implementing a hypothetical 3.1 version of
        the OpenSocial spec can continue to respond as if it was a 3.0 implementation:</preamble>
        <artwork>
  HTTP/1.1 200 OK
  Link: &lt;http://opensocial.org/specs/3.0&gt;; rel="profile"
  Content-Type: application/json
  
  {... OpenSocial 3.0 data ...}
        </artwork></figure>
     
        <figure><preamble>Or, it can perform an "in-place" upgrade:</preamble>
        <artwork>
  HTTP/1.1 200 OK
  Upgrade: OpenSocial/3.1
  Connection: upgrade
  Link: &lt;http://opensocial.org/specs/3.1&gt;; rel="profile"
  Content-Type: application/json
  
  {... OpenSocial 3.1 data ...}
        </artwork></figure>
        
        <t>Alternatively, the server MAY choose to deploy the new version 
        with a new URI and redirect the down-level client to the new version 
        of the application:</t>
        
        <figure><preamble>An upgrade redirection from the server:</preamble>
        <artwork>
  HTTP/1.1 301 Moved Permanently
  Location: /v3.1/api/people/@me/@self HTTP/1.1
  Upgrade: OpenSocial/3.1
  Connection: upgrade
  Link: &lt;http://opensocial.org/specs/3.1&gt;; rel="profile"
        </artwork></figure>
        
      </section>
   
    </section>
    <!--  END VERSIONING -->
    
    <section title="Registry of Service Identifiers" anchor="service-identifier-registry">
    
      <t>Every REST service is associated with a distinct service-identifier as
      defined by <xref target="service-identifiers"/>. The OpenSocial Social
      Applications Specification <xref target="social-app"/> defines the core 
      set of services and their associated identifiers.</t>
      
      <t>Implementations are free to introduce additional services so long as 
      each is identified by a unique service-identifier. To promote interoperability 
      across implementations, this specification establishes a Registry of Service 
      Identifiers to be hosted and managed by the OpenSocial Foundation. This 
      registry shall contain known, commonly used service identifiers. Whenever 
      an implementor defines and deploys support for new services, the 
      associated identifier SHOULD be added to the registry.</t>
      
      <t>Registrations require review by the OpenSocial community and are 
      subject to the following rules:</t>
      
      <list style="numbers">
        <t>A service identifier, once registered, stays registered forever.</t>
        <t>The registration MUST name a responsible party for the registration.</t>
        <t>The registration MUST name a point of contact.</t>
        <t>The registration MAY name a set of specifications associated with 
        the identifier. Such specifications SHOULD be publicly available.</t>
      </list>
      
      <t>The party responsible MUST submit the registration request via email 
      to the mailing list for the OpenSocial Specification Community Group. 
      After a period of 30-days following the date of the email request, if 
      there are no expicit objections from members of the community in response
      to the registration, the request will be assumed to be automatically
      accepted.</t>
    
    </section>
    <!-- END SERVICE REGISTRY -->
    
    <section title="Registry of Aspect Identifiers" anchor="aspect-identifier-registry">
    
      <t>For each distinctly-named REST Service (see <xref target="service-identifiers"/>),
      every individual data object can have zero or more individually identifiable
      aspects (see <xref target="aspect-identifiers"/>). The OpenSocial Social
      Applications Specification <xref target="social-app"/> defines the core 
      set of services and their associated aspect identifiers.</t>
      
      <t>Implementations are free to introduce additional aspects for any 
      service so long as each is identified by a unique aspect identifier. 
      To promote interoperability across implementations, this specification 
      establishes a Registry of Aspect Identifiers to be hosted and managed 
      by the OpenSocial Foundation. This registry shall contain known, commonly 
      used aspect identifiers. Whenever an implementor defines and deploys 
      support for new aspects, the associated identifier SHOULD be added to the
      registry.</t>
      
      <t>Registrations require review by the OpenSocial community and are 
      subject to the following rules:</t>
      
      <list style="numbers">
        <t>An aspect identifier, once registered, stays registered forever.</t>
        <t>The registration MUST name a responsible party for the registration.</t>
        <t>The registration MUST name a point of contact.</t>
        <t>The registration MAY name a set of specifications associated with 
        the identifier. Such specifications SHOULD be publicly available.</t>
        <t>The registration MUST name the service-identifier for which it is
        associated.</t>
      </list>
      
      <t>The party responsible MUST submit the registration request via email 
      to the mailing list for the OpenSocial Specification Community Group. 
      After a period of 30-days following the date of the email request, if 
      there are no expicit objections from members of the community in response
      to the registration, the request will be assumed to be automatically
      accepted.</t>
    
    </section>
    <!-- END ASPECT REGISTRY -->
  
  </middle>
  <back>
    <references title="Normative References"> 
      &rfc2119;
      &rfc3864;
      &rfc5226;
      &rfc2026;
      &rfc5234;
      &rfc6570;
      &rfc5789;
      &rfc5234;
      &rfc3986;
      &rfc3987;
      &rfc3339;
      &astreams;
      &astreamlinks;
      &profile;
      &part1;
      &part2;
      &part3;
      &part4;
      &part5;
      &part6;
      &part7;
      &socialapp;
      &coregadget;
      &jsonpatch;
      &mergepatch;
      &bearer;
      &mac;
    </references>
 </back>
</rfc>

  