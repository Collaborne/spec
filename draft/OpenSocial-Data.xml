<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='./OpenSocial.xslt' ?>
<?rfc toc="yes"?>
<?rfc-ext allow-markup-in-artwork="yes"?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
"http://xml.resource.org/authoring/rfc2629.dtd">
<rfc ipr="full3978"
     docName="opensocial-data-specification-draft"
     xmlns:x="http://purl.org/net/xml2rfc/ext">
 <front>
  <title>OpenSocial Data Specification (draft)</title>
  <author fullname='OpenSocial and Gadgets Specification Group'>
   <address>
    <email>opensocial-and-gadgets-spec@googlegroups.com</email>
   </address>
  </author>
  <date month="September"
        year="2009" />
  <abstract>
   <t>This document describes a method for making social network information
   and services programatically available on the internet.</t>
  </abstract>
 </front>
 <middle>
  <section title="Introduction">
   <section title="Requirements">
    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
    document are to be interpreted as described in 
    <xref target="RFC2119">RFC2119</xref>.</t>
    <t>An implementation is not compliant if it fails to satisfy one or more of
    the MUST or REQUIRED level requirements for the protocols it
    implements.</t>
   </section>
   <section title="Terminology">
    <t>This specification uses a number of terms to refer to the roles played
    by participants in, and objects of, an OpenSocial implementation.</t>
    <list style="hanging">
     <t hangText="container">An implementor of the 
     <xref target="Gadget-Specification">Gadget specification</xref> </t>
    </list>
   </section>
  </section>
  <section title="Notational Conventions and Generic Grammar">
   <section title="Conventions">
    <t>Domain name examples use 
    <xref target="RFC2606">RFC2606</xref>.</t>
   </section>
   <section title="Augmented BNF">
    <t>The grammatical rules in this document are to be interpreted as
    described in <xref target="RFC2234">RFC4234</xref> (Augmented Backus-Naur 
    Form).</t>   
    <t>The following constructs are introduced in this document to augment 
    RFC4234:</t>
    <list style="hanging">
     <t hangText="{rule1 rule2}">
      <t>Elements enclosed in braces (squiggly brackets) are treated as a
      single, UNORDERED element. Its contents may occur in any order. Hence: 
      <artwork type="abnf" xml:space="preserve">{elem foo} bar</artwork>
      would match (elem foo bar) and (foo elem bar).</t>
      <t>NOTE: Specifying alternatives is quite different from specifying set
      grouping. Alternatives indicate the matching of exactly one (sub-)rule
      out of the total grouping. The set mechanism indicates the matching of a
      string which contains all of the elements within the group; however the
      elements may occur in any order.</t>
     </t>
     <t hangText="#rule">A construct "#" is defined, similar to "*", for
     defining lists of elements. The full form is "&lt;n&gt;#&lt;m&gt;element"
     indicating at least &lt;n&gt; and at most &lt;m&gt; elements, each
     separated by one or more commas (",") and OPTIONAL linear white space
     (LWS). This makes the usual form of lists very easy; a rule such as 
     <artwork type="inline" xml:space="preserve">( *LWS element *( *LWS "," *LWS element ))</artwork>
     can be shown as 
     <artwork type="inline" xml:space="preserve">1#element</artwork>
     Wherever this construct is used, null elements are allowed, but do
     not contribute to the count of elements present. That is, "(element), ,
     (element) " is permitted, but counts as only two elements. Therefore, 
     where at least one element is required, at least one non-null element MUST 
     be present.  Default values are 0 and infinity so that "#element" allows 
     any number, including zero; "1#element" requires at least one; and 
     "1#2element" allows one or two.</t>
     <t hangText="&amp;rule">A construct "&amp;" is defined, similar to "#",
     which uses an ampersand (&amp;) instead of commas, and MUST NOT include
     linear white space between elements.</t>
     <t hangText="implied *LWS">The grammar described by this specification is
     word-based. Except where noted otherwise, linear white space (LWS) can be
     included between any two adjacent words (token or quoted-string), and
     between adjacent words and separators, without changing the interpretation
     of a field. At least one delimiter (LWS and/or separators) MUST exist
     between any two tokens, since they would otherwise be interpreted as a
     single token.</t>
    </list>
   </section>
   <section title="Basic Rules">
    <t>The following rules are used throughout this specification to describe
    basic parsing constructs. The US-ASCII coded character set is defined by 
    <xref target="RFC20" /> </t>
    <artwork type="abnf"
         xml:space="preserve">
<![CDATA[
OCTET          = <any 8-bit sequence of data>
CHAR           = <any US-ASCII character (octets 0 - 127)>
UPALPHA        = <any US-ASCII uppercase letter "A".."Z">
LOALPHA        = <any US-ASCII lowercase letter "a".."z">
ALPHA          = UPALPHA / LOALPHA
DIGIT          = <any US-ASCII digit "0".."9">
CTL            = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
CR             = <US-ASCII CR, carriage return (13)>
LF             = <US-ASCII LF, linefeed (10)>
SP             = <US-ASCII SP, space (32)>
HT             = <US-ASCII HT, horizontal-tab (9)>
<">            = <US-ASCII double-quote mark (34)>
CRLF           = CR LF
LWS            = [CRLF] 1*( SP / HT )
TEXT           = <any OCTET except CTLs, but including LWS>
COMMA          = <US-ASCII comma (44)>
      ]]>
</artwork>
   </section>
  </section>
  <section title="Protocols">
   <t>OpenSocial defines the following protocols for data access.</t>
   <section title="REST">
    <t>The OpenSocial REST protocol is defined on top of the HTTP protocol.</t>
    <section title="Request">
     <t>A REST request uses the following format:</t>
     <artwork type="abnf"
         xml:space="preserve">
<x:highlight>REST-Request</x:highlight>     = <x:ref>REST-HTTP-Method</x:ref> SP <x:u>REST-Request-URI</x:u> SP &lt;any valid HTTP version identifier&gt; CRLF
                   { 
                     "HOST: " &lt;any valid HTTP host&gt; CRLF
                     [ "Authorization: " <x:ref>OpenSocial-Auth-Token</x:ref> CRLF ]
                     [ "Content-Type: " <x:ref>OpenSocial-Content-Type</x:ref> CRLF ]
                     [ *(&lt;a valid HTTP header not defined above&gt; CRLF) ]
                   }
                   CRLF
                   [ <x:ref>REST-Request-Payload</x:ref> ]
<x:highlight>REST-Request-URI</x:highlight> = <x:ref>REST-Base-Path</x:ref> <x:ref>REST-URI-Fragment</x:ref> ["?" <x:ref>REST-Query-Parameters</x:ref>]
</artwork>
     <t>For example, here is a REST request to retrieve information about a
     user:</t>
     <artwork type="example"
         xml:space="preserve">
GET /api/people/@me/@self?fields=name HTTP/1.1
Host: api.example.org
Authorization: hh5s93j4hdidpola
Content-Type: application/json
</artwork>
     <section title="Request Payload"
              anchor="REST-Request-Payload"></section>
    </section>
    <section title="Response">
     <t>Responses from REST requests are</t>
    </section>
    <section title="HTTP Method"
             anchor="REST-HTTP-Method">
     <t>The following HTTP methods may be used for REST requests:</t>
     <artwork type="abnf"
         xml:space="preserve">
<x:highlight>REST-HTTP-Method</x:highlight> = "GET" / "POST" / "PUT" / "DELETE" 
</artwork>
     <t>Each REST resource defined in this document may specify the exact
     semantics of each method, but generally, "GET" is associated with
     retrieving a resource, "POST" is associated with creating a resource,
     "PUT" is associated with updating a resource, and "DELETE" is associated
     with deleting a resource.</t>
    </section>
    <section title="Base Path"
             anchor="REST-Base-Path">
     <t>An OpenSocial REST server may choose to expose their REST endpoints in
     a "namespaced" way through use of a path. For example, the REST resource
     of "http://www.example.com/apis/people" would have a REST base path of
     "/apis", while "http://www.example.com/apis/opensocial-1.0/people" would
     correspond with the REST base path of "/apis/opensocial-1.0".</t>
    </section>
    <section title="URI Fragment"
             anchor="REST-URI-Fragment">
     <t>This value will be defined consistently by each 
     <xref target="services">OpenSocial service</xref>. The value of the REST
     fragment helps define the exact resource which is targeted for the
     request.</t>
    </section>
    <section title="Query Parameters" anchor="REST-Query-Parameter">
     <x:anchor-alias value="REST-Query-Parameters" />
     <x:anchor-alias value="ENCODE-REST-PARAMETER" />
     <t>Additional parameters for a REST request will be passed via the
     querystring portion of the request URI.</t>

     
     <t>This specification defines a function ENCODE-REST-PARAMETER, which
     is an alias for encoding a key/value pair.  The PCT-ENCODE function 
     is described in section 2.1 of <xref target="RFC3986"/>.</t>
       <artwork type="abnf"
         xml:space="preserve">ENCODE-REST-PARAMETER(k,v) = PCT-ENCODE(k) "=" PCT-ENCODE(FLATTEN(v))</artwork>
         
     <t>The FLATTEN function is also defined in this spec, and behaves in
     the following manner:</t>
     
     <list style="numbers">
      <t>If the argument supplied is an array of strings or numbers, the 
      string representation of each array element is returned, with each element
      separated by a COMMA.</t>
      <t>If the argument supplied is a string or a number, the string 
      representation of the argument is returned.</t>
     </list>
     
     <t>The behavior of FLATTEN for input not explicitly covered here is 
     undefined.  This includes associtative arrays, or nested arrays.</t>
     
     <t>Here is an example of a REST request URL with query parameters.  Note that the fields parameter demonstrates a flattened array:</t>
     
     <artwork type="abnf">http://www.example.com/opensocial/rest/people/@me/@self?fields=name,gender&amp;format=json</artwork>
    </section>
   </section>
   
   
   <section title="RPC">
    <t>The OpenSocial RPC protocol is defined on top of the HTTP protocol.</t>
    <section title="RPC Request"
             anchor="RPC-Request">
     <t>An RPC request uses the following format:</t>
     <artwork type="abnf"
         xml:space="preserve">
RPC-Request = "POST /" <x:ref>RPC-Base-URL</x:ref> " HTTP/1.1"
              "HOST" &lt;any valid HTTP host&gt;
              "Authorization: " <x:ref>OpenSocial-Auth-Token</x:ref> 
              "Content-Type: " <x:ref>OpenSocial-Content-Type</x:ref> 
              <x:ref>RPC-Request-Payload</x:ref>
</artwork>
     <t>For example, here is a RPC request to retrieve information about a
     user:</t>
     <artwork type="example"
         xml:space="preserve">
POST /rpc HTTP/1.1
Host: api.example.org
Authorization: hh5s93j4hdidpola
Content-Type: application/json
{
  "method" : "people.get",
  "id" : "myself"
  "params" : {
    "userId" : "@me",
    "groupId" : "@self"
  }
}
</artwork>
     <section title="RPC Base URL"
              anchor="RPC-Base-URL">
      <t>The RPC Base URL is defined in the XRDS file.</t>
     </section>
     <section title="RPC Request Payload"
              anchor="RPC-Request-Payload">
      <t>RPC requests MAY batch multiple procedure calls into a single HTTP
      request. Therefore, the payload of an RPC request can container a JSON
      array of procedure calls, or a single procedure call:</t>
      <artwork type="abnf"
         xml:space="preserve">
<x:highlight>RPC-Request-Payload</x:highlight> = RPC-Batch-Payload / RPC-Single-Payload
<x:highlight>RPC-Batch-Payload</x:highlight> = "[" #RPC-Single-Payload "]"
<x:highlight>RPC-Single-Payload</x:highlight> = "{"
                        "method : " <x:ref>RPC-Method</x:ref> ","
                        "id : " <x:ref>OpenSocial-Request-ID</x:ref> ","
                        "params : " <x:ref>RPC-Request-Parameters</x:ref> 
                      "}"
</artwork>
      <t>Here is an example of a RPC request with a batch of procedure calls in
      the payload:</t>
      <artwork type="example"
         xml:space="preserve">
POST /rpc HTTP/1.1
Host: api.example.org
Authorization: hh5s93j4hdidpola
Content-Type: application/json
[
  {
    "method" : "people.get",
    "id" : "myself",
    "params" : {
      "userId" : "@me",
      "groupId" : "@self"
    }
  },
  {
    "method" : "people.get",
    "id" : "myfriends",
    "params" : {
      "userId" : "@me",
      "groupId" : "@friends"
    }
  }
]
</artwork>
      <section title="RPC Method"
               anchor="RPC-Method">
       <t>The RPC Method is a string.</t>
       <artwork type="abnf"
         xml:space="preserve">
RPC-Method = string
</artwork>
       <t>Available methods can be determined by calling the 
       <xref target="system.listMethods"/> method.</t>
      </section>
      <section title="RPC Request Parameters"
               anchor="RPC-Request-Parameters">
       <x:anchor-alias value="ENCODE-RPC-PARAMETER" />
       <t>Parameters can be passed to RPC methods in the request payload as a
       JSON object as described in <xref target="RFC4627"/></t>
       <t>Appropriate values for RPC request parameters can be determined by
       calling the 
       <xref target="system.methodSignatures"/> method.</t>
       <t>Here is an example of an RPC request payload with procedure-specific
       parameters (userId, groupId) and standard OpenSocial parameters:</t>
       <artwork type="example"
         xml:space="preserve">
{
  "method" : "people.get",
  "id" : "myself"
  "params" : {
    "userId" : "@me",
    "groupId" : "@self",
    "fields" : "name, gender",
    "format" : "json"
  }
}</artwork>
       <t>This specification defines a function ENCODE-RPC-PARAMETER which is
       an alias for the JSON encoding process.  This function takes a key and
       value as arguments, where the key must be a string, and the value must
       have a valid JSON encoding.</t>
       <artwork type="abnf"
         xml:space="preserve">ENCODE-RPC-PARAMETER(k,v) = "{" &lt;"&gt; k &lt;"&gt; ":" JSON-ENCODE(v) "}")</artwork>
      </section>
     </section>
    </section>
    <section title="RPC Response"
             anchor="RPC-Response">
     <t>An RPC response uses the following format:</t>
     <artwork type="example"
         xml:space="preserve">
HTTP/1.x 207 Multi-Status
"Content-Type: " <x:ref>OpenSocial-Content-Type</x:ref> 
<x:ref>RPC-Response-Payload</x:ref>
</artwork>
     <section title="RPC-Response-Payload"
              anchor="RPC-Response-Payload">
      <t>RPC responses MAY contain results from multiple procedure calls, if
      the corresponding HTTP request contained a 
      <x:ref>RPC-Batch-Payload</x:ref>. If processing of the entire batch
      fails, as opposed to a single request within the batch, then the returned
      value is a single 
      <x:ref>RPC-Error</x:ref>object with the appropriate error message and
      code.</t>
      <t>The response payload for a single procedure call MUST contain an 'id'
      property to correlate the response with a request. On success, the
      payload MUST contain a 'result' property, which can be any JSON object as
      defined by the procedure. On failure, the payload MUST contain an 'error'
      property.</t>
      <artwork type="abnf"
         xml:space="preserve">
<x:highlight>RPC-Response-Payload</x:highlight> = RPC-Batch-Payload / RPC-Single-Payload
<x:highlight>RPC-Batch-Payload</x:highlight> = <x:ref>RPC-Error</x:ref> / ("[" #RPC-Single-Payload"]")
<x:highlight>RPC-Single-Payload</x:highlight> = "{"
                       "id" : <x:ref>OpenSocial-Request-ID</x:ref> ","
                       ( ("result" : <x:ref>OpenSocial-Object</x:ref>) / ("error" : <x:ref>RPC-Error</x:ref>) )
                     "}"
</artwork>
      <t>The following examples illustrate how success and failure are
      represented in responses to batch requests. 
      <t>Batch successful, all procedure calls successful:</t>
      <artwork type="example"
         xml:space="preserve">
[
  { 
    "id" : "myself", 
    "result" : { ... }
  },
  { 
    "id" : "myfriends", 
    "result" : { ... }
  }           
]
</artwork>
      <t>Batch successful, some procedure calls successful while some fail:</t>
      <artwork type="example"
         xml:space="preserve">
[
  { 
    "id" : "myself", 
    "result" : { ... }
  },
  { 
    "id" : "myfriends", 
    "error" : { ... }
  }
]
</artwork>
      <t>Batch successful, all procedure calls fail:</t>
      <artwork type="example"
         xml:space="preserve">
[
  { 
    "id" : "myself", 
    "error" : { ... }
  },
  { 
    "id" : "myfriends", 
    "error" : { ... }
  }
]
</artwork>
      <t>Batch fails:</t>
      <artwork type="example"
         xml:space="preserve">
{
  "error" : { ... }
}
</artwork></t>
     </section>
     <section title="RPC Error"
              anchor="RPC-Error">
      <t>An error object MUST contain a 'code' property to indicate the actual
      error that occurred and MAY contain a 'message' property describing the
      error. Additional information may be returned in the 'data' property, as
      defined by the procedure.</t>
      <artwork type="abnf"
         xml:space="preserve">
RPC-Error = "{"
              ["message : " string "," ]
              ["data" : " <x:ref>JSON-Object</x:ref> "," ]
              "code : " integer ","
            "}"
</artwork>
      <t>Here is an example of a successful RPC reponse payload:</t>
      <artwork type="example"
         xml:space="preserve">
{
  "id" : "myself"
  "error" : {
    "code" : 401
    "message" : "The authorization token does not provide access to the requested resource."
  }
}
</artwork>
     </section>
    </section>
   </section>
  </section>
  <section title="Common Entities">
   <section title="HTTP Status Line"
            anchor="HTTP-Status-Line">
    <t>The HTTP status line is defined in Section 6.1 of the HTTP 1.1
    Specification</t>
   </section>
   <section title="OpenSocial Object"
            anchor="OpenSocial-Object">
    <t>The format of an OpenSocial object can be either JSON or XML, as
    specified by the 'format' parameter in the request.</t>
    <artwork type="abnf"
         xml:space="preserve">
OpenSocial-Object = <x:ref>JSON-Object</x:ref> / <x:ref>XML-Object</x:ref>
</artwork>
    <t>OpenSocial object is any single entity returned from an OpenSocial
    service, such as a person, activity.</t>
   </section>
   <section title="JSON Object"
            anchor="JSON-Object">
    <t>The syntax for JSON Objects are defined in the 
    <xref target="RFC4627"/>.</t>
   </section>
   <section title="XML Object"
            anchor="XML-Object">
   <t>XML Objects are equivalent to JSON objects. The XML format of a JSON
   object can be determined using the 
   <xref target="JSON-to-XML">rules for mapping JSON to
   XML</xref>.</t>.</section>
   <section title="OpenSocial Request ID"
            anchor="OpenSocial-Request-ID">
    <t>The OpenSocial Request ID is a string. In cases where multiple requests
    are processed in a batch, Request IDs are used in the response so the
    requester can properly map the individual responses to the appropriate
    requests.</t>
   </section>
   <section title="OpenSocial User ID"
            anchor="OpenSocial-User-ID">
    <t>One of the pieces of data that is always returned with a Person object
    is the user's ID. The user ID must only contain alphanumeric (A-Za-z0-9)
    characters, underscore(_), dot(.) or dash(-), and must uniquely identify
    the user in a container. This standardization is intended to allow for
    prefixing IDs with a domain name and separator to create globally unique
    IDs (e.g. "orkut.com:34KJDCSKJN2HHF0DW20394"). Note that there will likely
    be a size limit placed on user IDs to help manage storing IDs in a
    database.</t>
    <artwork type="abnf"
         xml:space="preserve">
OpenSocial-User-ID = [ Domain-Name ":" ] *( DIGIT / ALPHA / "_" / "-" / ".") / "@me" / "@viewer" / "@owner"
Domain-Name = string
</artwork>
   </section>
   <section title="OpenSocial User ID List"
            anchor="OpenSocial-User-ID-List">
    <t>For methods that accept a list of user IDs as a parameter, this list
    should be a string containing a comma-separated list of user IDs:</t>
    <artwork type="abnf"
         xml:space="preserve">
OpenSocial-User-ID-List = #<x:ref>OpenSocial-User-ID</x:ref>
</artwork>
   </section>
   <section title="OpenSocial Group ID"
            anchor="OpenSocial-Group-ID">
    <t>The group ID must only contain alphanumeric (A-Za-z0-9) characters,
    underscore(_), dot(.) or dash(-), and must uniquely identify the group in a
    container.</t>
    <artwork type="abnf"
         xml:space="preserve">
OpenSocial-Group-ID = *( DIGIT / ALPHA / "_" / "-" / ".") / "@self" / "@friends" / "@all"
</artwork>
   </section>
   <section title="Auth Token"
            anchor="OpenSocial-Auth-Token">
    <artwork type="abnf"
         xml:space="preserve">
OpenSocial-Auth-Token = string
</artwork>
    <t>Semantics for the Auth token are defined in 
    <xref>foo</xref> </t>
   </section>
   <section title="Standard Query Parameters"
            anchor="standard-query-parameters">
    <x:anchor-alias value="OpenSocial-Request-Parameter-Key" />
    <x:anchor-alias value="OpenSocial-Request-Parameter-Value" />
    <artwork type="abnf"
         xml:space="preserve">
<x:highlight>OpenSocial-Request-Parameter-Key</x:highlight>   = string
<x:highlight>OpenSocial-Request-Parameter-Value</x:highlight> = string
</artwork>
    <t>Most requests will accept the following OpenSocial-Request-Parameter-Key
    parameters:</t>
    <list style="hanging">
     <t hangText="count">The page size for a paged collection. If no parameter
     is specified the container can choose how many items in the collection
     should be returned. However, the container SHOULD support a large default
     count value so that all items can be returned by default.</t>
     <t hangText="filterBy">For a collection, return entries filtered by the
     given field name.</t>
     <t hangText="filterOp">The operation to use when filtering a collection by
     a field specified in 'filterBy', defaults to "contains". Valid values: 
     <list style="hanging">
      <t hangText="contains">Return elements where filterValue appears
      somewhere in the element's filterBy field value.</t>
      <t hangText="equals">Return elements where filterValue exactly matches
      the element's filterBy field value.</t>
      <t hangText="startsWith">Return elements where filterValue exactly
      matches the first N characters of the element's filterBy field value,
      where N is the length of the filterValue string.</t>
      <t hangText="present">Return elements where the element's filterBy field
      value is not empty or null.</t>
     </list></t>
     <t hangText="filterValue">The value to use when filtering a collection.
     For example: 
     <artwork type="example"
         xml:space="preserve">
{ ... "filterBy" : "name", "filterOp" : "startsWith", "filterValue" : "John" ... }
</artwork>returns all items whose name field starts with John. Johnny and John
Doe would both be included.)</t>
     <t hangText="sortOrder">Can either be 'ascending' or 'descending',
     defaults to ascending. Used to sort objects in a collection.</t>
     <t hangText="fields">An array of field names to include in the
     representation or in the members of a collection. If no fields are
     specified in the request it is up to the container to decide which fields
     to return, however, the response MUST always include a minimum set of
     fields. For people this is [id, name, thumbnailUrl]. For activities this
     is [id, title]. In place of an array '@all' is accepted to indicate
     returning all available fields.</t>
     <t hangText="networkDistance">Modifies group-relative requests (@friends,
     etc.) to include the transitive closure of all friends up to the specified
     distance away. MAY NOT be honored by the container.</t>
     <t hangText="startIndex">Index into a paged collection.</t>
     <t hangText="updatedSince">When specified the container should only return
     items whose updated date &amp; time is equal to or more recent then the
     specified value. The value MUST be a valid 
     <xref target="XSdateTime" /> (e.g. 2008-01-23T04:56:22Z).</t>
     <t hangText="format">Specifies the desired return encoding of the request.
     Must be one of "json", "xml", or "atom".</t>
    </list>
   </section>
   <section title="Standard Content Types"
            anchor="standard-content-types">
    <x:anchor-alias value="OpenSocial-Content-Type" />
   </section>
  </section>
  <section title="Services"
           anchor="services">
   <section title="People"
            anchor="People-Service">
    <section title="Retrieve a Person"
             anchor="People-Service-RetrievePerson">
     <t>Requests and responses for retrieving a person use the following values:</t>
     <artwork type="abnf"
         xml:space="preserve">
<x:ref>REST-HTTP-Method</x:ref>       = "GET"
<x:ref>REST-URI-Fragment</x:ref>      = "/people/" <x:ref>OpenSocial-User-ID</x:ref> "/@self"
<x:ref>REST-Query-Parameters</x:ref>  = {
                          [ <x:ref>ENCODE-REST-PARAMETER</x:ref>("fields", <x:ref>Query-Parameter-Fields-Value</x:ref>) ]
                          [ <x:ref>ENCODE-REST-PARAMETER</x:ref>("format", <x:ref>Query-Parameter-Format-Value</x:ref>) ]
                         }
<x:ref>REST-Request-Payload</x:ref>   = null
<x:ref>RPC-Method</x:ref>             = "people.get"
<x:ref>RPC-Request-Parameters</x:ref> = { 
                            <x:ref>ENCODE-RPC-PARAMETER</x:ref>("userId", <x:ref>OpenSocial-User-ID</x:ref>) 
                            <x:ref>ENCODE-RPC-PARAMETER</x:ref>("groupId", "@self")
                          [ <x:ref>ENCODE-RPC-PARAMETER</x:ref>("fields", <x:ref>Query-Parameter-Fields-Value</x:ref>) ] 
                         }
<x:ref>OpenSocial-Object</x:ref>      = <x:ref>OpenSocial-Person</x:ref></artwork>
     <t>Here's an example of a REST request to retrieve a person, and the
     associated response. Note that 'format=xml' is used to specify that the response should contain XML.
     <t>HTTP Request</t>
     <artwork type="example"
         xml:space="preserve">
GET /rest/people/@me/@self?fields=name,gender&amp;format=xml HTTP/1.1
HOST api.example.org
Authorization: hh5s93j4hdidpola</artwork>
     <t>HTTP Response</t>
     <artwork type="example"
         xml:space="preserve">
HTTP/1.1 200 OK
Content-Type: text/xml
&lt;response xmlns="http://ns.opensocial.org/2008/opensocial"&gt;
  &lt;person&gt;
    &lt;id&gt;example.org:34KJDCSKJN2HHF0DW20394&lt;/id&gt;
    &lt;name&gt;
      &lt;unstructured&gt;Jane Doe&lt;/unstructured&gt;
    &lt;/name&gt;
    &lt;gender&gt;female&lt;/gender&gt;
  &lt;/person&gt;
&lt;/response&gt;</artwork>
     </t>
     <t>Here's an example of a RPC request to retrieve a person, and the
     associated response.
     <t>HTTP Request</t>
     <artwork type="example"
         xml:space="preserve">
POST /rpc HTTP/1.1
Host: api.example.org
Authorization: hh5s93j4hdidpola
Content-Type: application/json
{
  "method" : "people.get",
  "id" : "myself"
  "params" : {
    "userId" : "@me",
    "groupId" : "@self",
    "fields" : [ "name", "gender" ]
  }
}</artwork>
     <t>HTTP Response</t>
     <artwork type="example"
         xml:space="preserve">
HTTP/1.x 207 Multi-Status
Content-Type: application/json
{
   "id" : "myself"
   "result" : {
     "id" : "example.org:34KJDCSKJN2HHF0DW20394",
     "name" : { "unstructured" : "Jane Doe"},
     "gender" : "female"
   }
}</artwork>
     </t>
    </section>
    <section title="Retrieve a list of People"
             anchor="People-Service-RetrievePeople">
     <t>Requests and responses for retrieving a list of people use the following values:</t>
     <artwork type="abnf"
         xml:space="preserve">
<x:ref>REST-HTTP-Method</x:ref>       = "GET"
<x:ref>REST-URI-Fragment</x:ref>      = "/people/" <x:ref>OpenSocial-User-ID</x:ref> "/" <x:ref>OpenSocial-Group-ID</x:ref> [ "/" <x:ref>OpenSocial-User-ID</x:ref> ]
<x:ref>REST-Query-Parameters</x:ref>  = TODO: Add optional parameters
<x:ref>REST-Request-Payload</x:ref>   = null
<x:ref>RPC-Method</x:ref>             = "people.get"
<x:ref>RPC-Request-Parameters</x:ref> = ( "userId : " ( <x:ref>OpenSocial-User-ID</x:ref> / <x:ref>OpenSocial-User-ID-List</x:ref> )
                         ( "groupId : " <x:ref>OpenSocial-Group-ID</x:ref> )
                         [ TODO: Add optional parameters ]
<x:ref>OpenSocial-Object</x:ref>      = <x:ref>OpenSocial-Collection</x:ref>&lt;<x:ref>OpenSocial-Person</x:ref>&gt;</artwork>
    <t>Here's an example of a REST request to retrieve a list of the current user's friends, and the associated response. Note that 'format=xml' is used to specify that the response should contain XML.
     <t>HTTP Request</t>
     <artwork type="example"
         xml:space="preserve">
GET /rest/people/@me/@friends?fields=name,gender&amp;format=xml HTTP/1.1
HOST api.example.org
Authorization: hh5s93j4hdidpola</artwork>
     <t>HTTP Response</t>
     <artwork type="example"
         xml:space="preserve">
HTTP/1.1 200 OK
Content-Type: text/xml
&lt;response xmlns="http://ns.opensocial.org/2008/opensocial"&gt;
  &lt;startIndex&gt; 1 &lt;/startIndex&gt;
  &lt;itemsPerPage&gt; 2 &lt;/itemsPerPage&gt;
  &lt;totalResults&gt; 100 &lt;/totalResults&gt;
  &lt;entry&gt;
    &lt;person&gt;
      &lt;id&gt;example.org:34KJDCSKJN2HHF0DW20394&lt;/id&gt;
      &lt;name&gt;
        &lt;unstructured&gt;Jane Doe&lt;/unstructured&gt;
      &lt;/name&gt;
      &lt;gender&gt;female&lt;/gender&gt;
    &lt;/person&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;person&gt;
      &lt;id&gt;example.org:34KJDCSKJN2HHF0DW20394&lt;/id&gt;
      &lt;name&gt;
        &lt;unstructured&gt;Jane Doe&lt;/unstructured&gt;
      &lt;/name&gt;
      &lt;gender&gt;female&lt;/gender&gt;
    &lt;/person&gt;
  &lt;/entry&gt; 
&lt;/response&gt;</artwork>
     </t>
     <t>Here's an example of a RPC request to retrieve a person, and the
     associated response.
     <t>HTTP Request</t>
     <artwork type="example"
         xml:space="preserve">
POST /rpc HTTP/1.1
Host: api.example.org
Authorization: hh5s93j4hdidpola
Content-Type: application/json
{
  "method" : "people.get",
  "id" : "myself"
  "params" : {
    "userId" : "@me",
    "groupId" : "@self",
    "fields" : "name, gender"
  }
}</artwork>
     <t>HTTP Response</t>
     <artwork type="example"
         xml:space="preserve">
HTTP/1.x 207 Multi-Status
Content-Type: application/json
{
   "id" : "myself"
   "result" : {
     "id" : "example.org:34KJDCSKJN2HHF0DW20394",
     "name" : { "unstructured" : "Jane Doe"},
     "gender" : "female"
   }
}</artwork>
     </t>
    </section>
    <section title="Retrieve a list of supported Person fields" anchor="People-Service-GetSupportedFields">
    </section>
    <section title="Retrieve a list of deleted friends" anchor="People-Service-GetDeletedFriends">
    </section>
    <section title="Create a Person"
             anchor="People-Service-CreatePerson"></section>
    <section title="Update a Person"
             anchor="People-Service-UpdatePerson"></section>
    <section title="Delete a Person"
             anchor="People-Service-DeletePerson"></section>
    <section title="Create a list of Friends"
             anchor="People-Service-CreateFriends"></section>
    <section title="Update a list of Friends"
             anchor="People-Service-UpdateFriends"></section>
    <section title="Delete a list of Friends"
             anchor="People-Service-DeleteFriends"></section>
   </section>
   <section title="Groups"
            anchor="Groups-Service">
    <section title="Create a list of Groups"
             anchor="Groups-Service-CreateGroups"></section>
    <section title="Retrieve a list of Groups"
             anchor="Groups-Service-RetrieveGroups"></section>
    <section title="Update a list of Groups"
             anchor="Groups-Service-UpdateGroups"></section>
    <section title="Delete a list of Groups"
             anchor="Groups-Service-DeleteGroups"></section>
   </section>
   <section title="Activities"
            anchor="Activities-Service"></section>
   <section title="AppData"
            anchor="AppData-Service"></section>
   <section title="Albums"
            anchor="Albums-Service"></section>
   <section title="MediaItems"
            anchor="MediaItems-Service"></section>
   <section title="Invalidation"
            anchor="Invalidation-Service"></section>
  </section>
  <section title="Data"
           anchor="data">
   <section title="OpenSocial-Account" anchor="OpenSocial-Account">
     <t>TODO</t>
   </section>
   <section title="OpenSocial-Address" anchor="OpenSocial-Address">
     <t>TODO</t>
   </section>
   <section title="OpenSocial-AppData" anchor="OpenSocial-AppData">
     <t>TODO</t>
   </section>
   <section title="OpenSocial-Boolean" anchor="OpenSocial-Boolean">
     <t>TODO</t>
   </section>
   <section title="OpenSocial-Collection"
            anchor="OpenSocial-Collection">
    <t>Many service operations return a list of OpenSocial resources. Lists are
    always returned in the "list" field of the result. Lists can either be the
    full set of resources or a pageable subset. If the operation supports
    random access indexing of the full list it will support the "startIndex"
    and "count" parameters which control what sublist of the full list is
    returned. The paging mechanisms described here are based on the OpenSearch
    standard with the additional requirement that all indexes are 0 based.</t>
    <artwork type="abnf"
         xml:space="preserve">
OpenSocial-Collection = "{"
                        "result : {"
                          [ "totalResults : " number "," ]
                          [ "startIndex : " number "," ]
                          [ "itemsPerPage : " number ", ]
                          [ "isFiltered : " ( "true" / "false" ) "," ]
                          [ "isUpdatedSince : " ( "true" / "false" ) "," ]
                          [ "itemsPerPage : " number "," ]
                          "list :" OpenSocial-Objects 
                        "}"
                      "}"
OpenSocial-Objects = "[" #<x:ref>OpenSocial-Object</x:ref> "]"
</artwork>
   </section>
   <section title="OpenSocial-Date" anchor="OpenSocial-Date">
     <t>TODO</t>
   </section>
   <section title="OpenSocial-Date-UTC-Offset" anchor="OpenSocial-Date-UTC-Offset">
     <t>TODO</t>
   </section>
   <section title="OpenSocial-Name"
            anchor="OpenSocial-Name">
    <t>TODO</t>
   </section>
   <section title="OpenSocial-Organization" anchor="OpenSocial-Organization">
     <t>TODO</t>
   </section>
   <section title="OpenSocial-Person"
            anchor="OpenSocial-Person">
     <t>Each person returned MUST include the id and displayName fields with non-empty values, but all other fields are optional, and it is recognized that not all Service Providers will be able to provide data for all the supported fields. The field list below is broad so that there is a standard field name available among Service Providers that do support any of these fields.</t>
     <artwork type="abnf">
<x:highlight>OpenSocial-Person</x:highlight>          = "{"
                               "id :" OpenSocial-User-ID ","
                               "displayName :" string ","
                               [ #OpenSocial-Person-Field ]
                             "}"</artwork>
     <t>Valid definitions for OpenSocial-Person-Field are listed in the table below.</t>
     <texttable>
      <ttcol align="left" width="15%">Field Name</ttcol>
      <ttcol align="left" width="21%">Field Type</ttcol>
      <ttcol align="left">Description</ttcol>
      <c>accounts</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;<x:ref>OpenSocial-Account</x:ref>&gt;</c>
      <c>An online account held by this Person.</c>
      <c>addresses</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;<x:ref>OpenSocial-Address</x:ref>&gt;</c>
      <c>A physical mailing address for this Person.</c>
      <c>anniversary</c>
      <c><x:ref>OpenSocial-Date</x:ref></c>
      <c>The wedding anniversary of this person. The value MUST be a valid
      xs:date (e.g. 1975-02-14). The year value MAY be set to 0000 when the
      year is not available.</c>
      <c>appdata</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;<x:ref>OpenSocial-AppData</x:ref>&gt;</c>
      <c>A collection of AppData keys and values.</c>
      <c>birthday</c>
      <c><x:ref>OpenSocial-Date</x:ref></c>
      <c>The birthday of this person. The value MUST be a valid xs:date (e.g.
      1975-02-14). The year value MAY be set to 0000 when the age of the Person
      is private or the year is not available.</c>
      <c>connected</c>
      <c><x:ref>OpenSocial-Boolean</x:ref></c>
      <c>Boolean value indicating whether the user and this Person have
      established a bi-directionally asserted connection of some kind on the
      Service Provider's service. The value MUST be either true or false. The
      value MUST be true if and only if there is at least one value for the
      relationship field, described below, and is thus intended as a summary
      value indicating that some type of bi-directional relationship exists,
      for Consumers that aren't interested in the specific nature of that
      relationship. For traditional address books, in which a user stores
      information about other contacts without their explicit acknowledgment,
      or for services in which users choose to "follow" other users without
      requiring mutual consent, this value will always be false.</c>
      <c>displayName</c>
      <c>string</c>
      <c><x:highlight>Required.</x:highlight> The name of this Person, suitable for display to end-users. Each
      Person returned MUST include a non-empty displayName value. The name
      SHOULD be the full name of the Person being described if known (e.g.
      Cassandra Doll or Mrs. Cassandra Lynn Doll, Esq.), but MAY be a username
      or handle, if that is all that is available (e.g. doll). The value
      provided SHOULD be the primary textual label by which this Person is
      normally displayed by the Service Provider when presenting it to
      end-users.</c>
      <c>emails</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;string&gt;</c>
      <c>E-mail address for this Person. The value SHOULD be canonicalized by
      the Service Provider, e.g.joseph@plaxo.com instead of
      joseph@PLAXO.COM.</c>
      <c>gender</c>
      <c>string</c>
      <c>The gender of this person. Service Providers SHOULD return one of the
      following Canonical Values, if appropriate:male, female, or undisclosed,
      and MAY return a different value if it is not covered by one of these
      Canonical Values.</c>
      <c>id</c>
      <c><x:ref>OpenSocial-User-ID</x:ref></c>
      <c><x:highlight>Required.</x:highlight> Unique identifier for the Person. Each Person returned MUST include a
      non-empty id value. This identifier MUST be unique across this user's
      entire set of people, but MAY not be unique across multiple users' data.
      It MUST be a stable ID that does not change when the same contact is
      returned in subsequent requests. For instance, an e-mail address is not a
      good id, because the same person may use a different e-mail address in
      the future. Usually, in internal database ID will be the right choice
      here, e.g. "12345".</c>
      <c>ims</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;string&gt;</c>
      <c>Instant messaging address for this Person. No official
      canonicalization rules exist for all instant messaging addresses, but
      Service Providers SHOULD remove all whitespace and convert the address to
      lowercase, if this is appropriate for the service this IM address is used
      for. Instead of the standard Canonical Values for type, this field
      defines the following Canonical Values to represent currently popular IM
      services: aim, gtalk, icq, xmpp,msn, skype, qq, and yahoo.</c>
      <c>name</c>
      <c><x:ref>OpenSocial-Name</x:ref></c>
      <c>The broken-out components and fully formatted version of the person's
      real name.</c>
      <c>nickname</c>
      <c>string</c>
      <c>The casual way to address this Person in real life, e.g. "Bob" or
      "Bobby" instead of "Robert". This field SHOULD NOT be used to represent a
      user's username (e.g. jsmarr or daveman692); the latter should be
      represented by the preferredUsername field.</c>
      <c>note</c>
      <c>string</c>
      <c>Notes about this person, with an unspecified meaning or usage
      (normally notes by the user about this person). This field MAY contain
      newlines.</c>
      <c>organizations</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;<x:ref>OpenSocial-Organization</x:ref>&gt;</c>
      <c>A current or past organizational affiliation of this Person.</c>
      <c>phoneNumbers</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;string&gt;</c>
      <c>Phone number for this Person. No canonical value is assumed here. In
      addition to the standard Canonical Values for type, this field also
      defines the additional Canonical Values mobile, fax, and pager.</c>
      <c>photos</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;string&gt;</c>
      <c>URL of a photo of this person. The value SHOULD be a canonicalized
      URL, and MUST point to an actual image file (e.g. a GIF, JPEG, or PNG
      image file) rather than to a web page containing an image. Service
      Providers MAY return the same image at different sizes, though it is
      recognized that no standard for describing images of various sizes
      currently exists. Note that this field SHOULD NOT be used to send down
      arbitrary photos taken by this user, but specifically profile photos of
      the contact suitable for display when describing the contact.</c>
      <c>preferredUsername</c>
      <c>string</c>
      <c>The preferred username of this person on sites that ask for a username
      (e.g. jsmarr or daveman692). This field may be more useful for describing
      the owner (i.e. the value when /@me/@self is requested) than the user's
      person, e.g. Consumers MAY wish to use this value to pre-populate a
      username for this user when signing up for a new service.</c>
      <c>published</c>
      <c><x:ref>OpenSocial-Date</x:ref></c>
      <c>The date this Person was first added to the user's address book or
      friends list (i.e. the creation date of this entry). The value MUST be a
      valid 
      <xref target="XSdateTime" /> (e.g. 2008-01-23T04:56:22Z).</c>
      <c>relationships</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;string&gt;</c>
      <c>A bi-directionally asserted relationship type that was established
      between the user and this person by the Service Provider. The value
      SHOULD conform to one of the XFN relationship values (e.g. kin, friend,
      contact, etc.) if appropriate, but MAY be an alternative value if needed.
      Note this field is a parallel set of category labels to the tags field,
      but relationships MUST have been bi-directionally confirmed, whereas tags
      are asserted by the user without acknowledgment by this Person. Note that
      this field consists only of a string value.</c>
      <c>tags</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;string&gt;</c>
      <c>A user-defined category label for this person, e.g. "favorite" or
      "web20". These values SHOULD be case-insensitive, and there SHOULD NOT be
      multiple tags provided for a given person that differ only in case. Note
      that this field consists only of a string value.</c>
      <c>updated</c>
      <c><x:ref>OpenSocial-Date</x:ref></c>
      <c>The most recent date the details of this Person were updated (i.e. the
      modified date of this entry). The value MUST be a valid 
      <xref target="XSdateTime" /> (e.g. 2008-01-23T04:56:22Z). If this Person
      has never been modified since its initial creation, the value MUST be the
      same as the value of published. Note the updatedSince Query Parameter can
      be used to select only people whose updated value is equal to or more
      recent than a given xs:dateTime. This enables Consumers to repeatedly
      access a user's data and only request newly added or updated contacts
      since the last access time.</c>
      <c>urls</c>
      <c><x:ref>OpenSocial-Plural-Field</x:ref> &lt;string&gt;</c>
      <c>URL of a web page relating to this Person. The value SHOULD be
      canonicalized by the Service Provider, e.g.http://josephsmarr.com/about/
      instead of JOSEPHSMARR.COM/about/. In addition to the standard Canonical
      Values for type, this field also defines the additional Canonical Values
      blog and profile.</c>
      <c>utcOffset</c>
      <c><x:ref>OpenSocial-Date-UTC-Offset</x:ref></c>
      <c>The offset from UTC of this Person's current time zone, as of the time
      this response was returned. The value MUST conform to the offset portion
      of 
      <xref target="XSdateTime" />, e.g. -08:00. Note that this value MAY
      change over time due to daylight saving time, and is thus meant to
      signify only the current value of the user's timezone offset.</c>
     </texttable>
     <t>The following additional fields are defined, based on
     their specification in the OpenSocial Javascript API, and are represented with strings: aboutMe,
     bodyType,currentLocation, drinker, ethnicity, fashion, happiestWhen,
     humor, livingArrangement, lookingFor, profileSong,profileVideo,
     relationshipStatus, religion, romance, scaredOf, sexualOrientation,
     smoker, and status.</t>
   </section>
   <section title="OpenSocial-Plural-Field" anchor="OpenSocial-Plural-Field">
     <texttable>
      <ttcol align="left" width="10%">Field Name</ttcol>
      <ttcol align="left" width="15%">Field Type</ttcol>
      <ttcol align="left">Description</ttcol>
      <c>value</c>
      <c><x:ref>OpenSocial-Object</x:ref></c>
      <c>The primary value of this field, e.g. the actual e-mail address, phone
      number, or URL. When specifying a sortBy field in the Query Parameters for
      a Plural Field, the default meaning is to sort based on this value
      sub-field. Each non-empty Plural Field value MUST contain at least the
      value sub-field, but all other sub-fields are optional.</c>
      <c>type</c>
      <c>string</c>
      <c>The type of field for this instance, usually used to label the
      preferred function of the given contact information. Unless otherwise
      specified, this string value specifies Canonical Values of work, home,
      and other.</c>
      <c>primary</c>
      <c><x:ref>OpenSocial-Boolean</x:ref></c>
      <c>A Boolean value indicating whether this instance of the Plural Field
      is the primary or preferred value of for this field, e.g. the preferred
      mailing address or primary e-mail address. Service Providers MUST NOT
      mark more than one instance of the same Plural Field as primary="true",
      and MAY choose not to mark any fields as primary, if this information is
      not available. For efficiency, Service Providers SHOULD NOT mark all
      non-primary fields with primary="false", but should instead omit this
      sub-field for all non-primary instances.</c>
     </texttable>
     <t>When returning Plural Fields, Service Providers SHOULD canonicalize the
     value returned, if appropriate (e.g. for e-mail addresses and URLs).
     Providers MAY return the same value more than once with different types
     (e.g. the same e-mail address may used for work and home), but SHOULD NOT
     return the same (type, value) combination more than once per Plural Field,
     as this complicates processing by the Consumer.</t>
   </section>
  </section>
  <section title="Rules for mapping JSON to XML"
           anchor="JSON-to-XML">
   <t>Singular fields are encoded as string key/value pairs in JSON and tags
   with text content in XML, e.g. "field": "value" and
   &lt;field&gt;value&lt;/field&gt; respectively.</t>
   <t>Plural fields are encoded as arrays in JSON and repeated tags in XML,
   e.g. "fields": [ "value1", "value2" ] and
   &lt;fields&gt;value1&lt;/field&gt;&lt;fields&gt;value2&lt;/field&gt;
   respectively.</t>
   <t>Nodes with multiple sub-nodes are represented as objects in JSON and tags
   with sub-tags in XML, e.g. "field": { "subfield1": "value1", "subfield2":
   "value2" } and
   &lt;field&gt;&lt;subfield1&gt;value1&lt;/subfield1&gt;&lt;subfield2&gt;value2&lt;/subfield2&gt;&lt;/field&gt;
   respectively.</t>
  </section>
 </middle>
 <back>
  <references>
   <reference anchor="RFC2234">
     <seriesInfo name='RFC' value='2234' />
   </reference>
   <reference anchor="RFC20">
     <seriesInfo name='RFC' value='20' />
   </reference>
   <reference anchor="RFC3986">
     <seriesInfo name='RFC' value='3986' />
   </reference>   
   <reference anchor="RFC4627">
     <seriesInfo name='RFC' value='4627' />
   </reference>   


   <reference anchor='RFC2119'>
    <front>
     <title>Key words for use in RFCs to Indicate Requirement Levels</title>
     <author initials='S.'
             surname='Bradner'
             fullname='Scott Bradner'>
      <organization abbrev='HarvardU'>Harvard University</organization>
     </author>
     <date month='March'
           year='1997' />
    </front>
    <seriesInfo name='RFC' value='2119' />
   </reference>
   <reference anchor='RFC2606'>
    <front>
     <title>Reserved Top Level DNS Names</title>
     <author initials='D.'
             surname='Eastlake'
             fullname='Donald E. Eastlake 3rd'>
      <organization abbrev='IBM'>IBM</organization>
     </author>
     <author initials='A.'
             surname='Panitz'
             fullname='Aliza R. Panitz'></author>
     <date month='June'
           year='1999' />
    </front>
    <seriesInfo name='RFC'
                value='2606' />
   </reference>
   <reference anchor='RFC2616'>
    <front>
     <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    </front>
    <seriesInfo name='RFC'
                value='2616' />
   </reference>
   <reference anchor='JSPEL'
              target="https://jsp.dev.java.net/spec/jsp-2_1-fr-spec-el.pdf">
    <front>
     <title>Java Server Pages Expression Language</title>
     <author initials='K.'
             surname='Chung'
             fullname='Kin-Man Chung'></author>
     <author initials='P.'
             surname='DeLisle'
             fullname='Pierre Delisle'></author>
     <author initials='M.'
             surname='Roth'
             fullname='Mark Roth'></author>
     <date month='May'
           year='2006' />
    </front>
   </reference>
   <reference anchor="XSdateTime"
              target="http://www.w3.org/TR/xmlschema-2/#dateTime">
    <front>
     <title>XML Schema Part 2: Datatypes Second Edition</title>
     <author initials='P.V.'
             surname='Biron'
             fullname='Paul V. Biron'>
      <organization>Kaiser Permanente, for Health Level Seven</organization>
     </author>
     <author initials='A.'
             surname='Malhotra'
             fullname='Ashok Malhotra'>
      <organization>Microsoft</organization>
     </author>
     <date month='October'
           year='2004' />
    </front>
   </reference>
  </references>
 </back>
</rfc>
